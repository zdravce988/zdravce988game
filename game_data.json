{"name": "Real number game", "version": "0.1.0", "languages": ["en"], "translated_name": "0", "devmode": false, "library_zip_fn": "Real number game-0.1.0-library.zip", "introData": {"name": "", "problemIndex": -1, "objects": [{"type": "text", "content": "1"}]}, "worlds": [{"name": "2", "levels": [{"name": "", "problemIndex": 10, "objects": [{"type": "lean", "content": "3", "hidden": true}, {"type": "lean", "content": "4", "hidden": true}, {"type": "lean", "content": "5", "hidden": true}, {"type": "lean", "content": "6", "hidden": true}, {"type": "lean", "content": "7", "hidden": false}, {"type": "text", "content": "8"}, {"type": "axiom", "content": "9", "name": "subset_iff :", "sideBar": true}, {"type": "hint", "content": "10", "title": "11"}, {"type": "hint", "content": "12", "title": "13"}, {"type": "text", "content": "14"}, {"type": "lemma", "text": "15", "lean": "lemma subset.refl (A : set X) : A \u2286 A :=\n", "sideBar": true, "firstProofLineNumber": 77, "lastProofLineNumber": 82, "textBefore": "import data.set.basic -- hide\n\nimport kb_defs -- hide\n\nnamespace xena -- hide\n\nopen_locale classical -- hide\n\nvariable X : Type -- we will think of X as a set here\n\n/-\n# Chapter 1 : Sets\n\n## Level 1 : Introduction to sets.\n\nThis chapter assumes you are familiar with the following tactics:\n`rw`, `intro`, `apply`, `exact`, `cases`, `split`, `use`, `left`, `right` and `exfalso`.\n\n(TODO (kmb) : check this list is exhaustive)\n(We might need to add `ring`)\n\nIf you are not, try playing Function World and Proposition World of the Natural Number Game.\n\n## Sets in Lean\n\nIn this world, there will be an ambient \"big\" set `X` (actually `X` will be a type),\nand we will consider subsets of `X`. The type of subsets of `X` is called `set X`.\nSo if you see `A : set X` it means that `A` is a subset of `X`.\n\n## subsets (\u2286) and `subset_iff`\n\nIf `A B : set X` (i.e. `A` and `B` are subsets of `X`), then `A \u2286 B` is a\nProposition, i.e. a true/false statement. Lean knows the following fact:\n\n```\nsubset_iff : A \u2286 B \u2194 \u2200 x : X, x \u2208 A \u2192 x \u2208 B\n```\n\nLet's see if you can prove `A \u2286 A` by rewriting `subset_iff`.\n-/\n\n/- Axiom : subset_iff :\nA \u2286 B \u2194 \u2200 x : X, x \u2208 A \u2192 x \u2208 B\n-/\n\n/- Hint : Tactic tip\nThe `assumption` tactic will close a goal if it is equal to one of your\nhypotheses. It's actually longer to type than `exact hx`, but it's easier to\nuse because you don't have to bother remembering what you called `hx`.\n\n-/\n/- Hint : Stuck? Here's a hint.\nTo make progress with a goal of form `\u2200 a : X, ...`, introduce a term of type `X` by using a familiar tactic. \n\nIn this example, using\n\n`intro a,`\n\nwill introduce an arbitrary term of type `X`.\n\nNote that this is the tactic we use to assume a hypothesis (when proving an implication), or to choose an arbitrary element of some domain (when defining a function).\n\nUse the same tactic to introduce an appropriately named hypothesis for an implication, and close the goal with the `exact` tactic.\n-/\n\n/-\nIf you get stuck, you can click on the hints for more details!\n-/\n\n\n\n/- Lemma\nIf $A$ is a set of elements of type X, then $A \\subseteq A$. \n-/\nlemma subset.refl (A : set X) : A \u2286 A :=\nbegin\n", "proof": "  rw subset_iff,\n  intros x h,\n  exact h\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\nend xena --hide\n", "height": 6, "editorText": "sorry", "lineOffset": 76, "name": "subset.refl", "statement": "(A : set X) : A \u2286 A"}, {"type": "lean", "content": "16", "hidden": true}], "url": ""}, {"name": "", "problemIndex": 9, "objects": [{"type": "lean", "content": "17", "hidden": true}, {"type": "lean", "content": "18", "hidden": true}, {"type": "lean", "content": "19", "hidden": true}, {"type": "lean", "content": "20", "hidden": true}, {"type": "text", "content": "21"}, {"type": "text", "content": "22"}, {"type": "axiom", "content": "23", "name": "mem_union_iff :", "sideBar": true}, {"type": "hint", "content": "24", "title": "25"}, {"type": "hint", "content": "26", "title": "27"}, {"type": "lemma", "text": "28", "lean": "theorem subset_union_left (A B : set X) : A \u2286 A \u222a B :=\n", "sideBar": true, "firstProofLineNumber": 54, "lastProofLineNumber": 60, "textBefore": "import game.sets.sets_level01 -- hide\n\nnamespace xena -- hide\n\nopen_locale classical -- hide\n\nvariable X : Type -- hide\n\n/-\n# Chapter 1 : Sets\n\n## Level 2 : union (\u222a)\n-/\n\n/- \nWorking with sets is very similar to working with propositions.\nLet's now prove that any set $A$ is included in its union with \nany other set $B$, or $A \u2286 A \u222a B$. To work with unions you will\nneed to know the property which classifies them:\n\n```\nmem_union_iff : x \u2208 A \u222a B \u2194 x \u2208 A \u2228 x \u2208 B\n```\n\nYou need to get yourself into a situation where the left hand side\nof `mem_union_iff` is in your goal; that way, you can `rw mem_union_iff`\nand make progress.\n-/\n\n/- Axiom : mem_union_iff :\nx \u2208 A \u222a B \u2194 x \u2208 A \u2228 x \u2208 B\n-/\n\n/- Hint : Tactic tip : intros\n`intros` is like `intro` but can be used to introduce more than one\nthing at once. For example if your goal is `\u22a2 \u2200 (x : X), x \u2208 A \u2192 x \u2208 A \u222a B`\nthen `intros x hx` will do the same as `intro x, intro hx`.\n-/\n\n/- Hint : Stuck?\nWe start with a rewrite (see level 1).\nThen, after introducing your terms, you'll be able to pull off\nthe second rewrite. Finally, you'll need to prove the `left`\nside of an `or` goal.\n-/\n\n\n/- Lemma\nIf $A$ and $B$ are sets of any type $X$, then\n$$ A \\subseteq A\\cup B.$$ \n-/\ntheorem subset_union_left (A B : set X) : A \u2286 A \u222a B :=\nbegin\n", "proof": "  rw subset_iff,\n  intros x hxA,\n  rw mem_union_iff,\n  left,\n  assumption,\n\n  ", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena --hide\n", "height": 7, "editorText": "sorry", "lineOffset": 53, "name": "subset_union_left", "statement": "(A B : set X) : A \u2286 A \u222a B"}, {"type": "lean", "content": "29", "hidden": true}], "url": ""}, {"name": "", "problemIndex": 11, "objects": [{"type": "lean", "content": "30", "hidden": true}, {"type": "lean", "content": "31", "hidden": true}, {"type": "lean", "content": "32", "hidden": true}, {"type": "lean", "content": "33", "hidden": true}, {"type": "text", "content": "34"}, {"type": "text", "content": "35"}, {"type": "axiom", "content": "36", "name": "mem_inter_iff :", "sideBar": true}, {"type": "hint", "content": "37", "title": "38"}, {"type": "hint", "content": "39", "title": "40"}, {"type": "hint", "content": "41", "title": "42"}, {"type": "hint", "content": "43", "title": "44"}, {"type": "lemma", "text": "45", "lean": "theorem intersection_subset (A B : set X) : A \u2229 B \u2286 A  :=\n", "sideBar": true, "firstProofLineNumber": 62, "lastProofLineNumber": 68, "textBefore": "import game.sets.sets_level02 -- hide\n\nnamespace xena -- hide\n\nopen_locale classical -- hide\n\nvariable X : Type -- hide\n\n/-\n# Chapter 1 : Sets\n\n## Level 3 : intersection (\u2229)\n-/\n\n\n/- \nNow prove that for any two sets $A$ and $B$, $A \u2229 B \u2286 A$.\n   \nYou will need to rewrite the following term:\n\n```\nmem_inter_iff : x \u2208 A \u2229 B \u2194 x \u2208 A \u2227 x \u2208 B \n```\n-/\n\n/- Axiom : mem_inter_iff :\nx \u2208 A \u2229 B \u2194 x \u2208 A \u2227 x \u2208 B\n-/\n\n/- Hint : Stuck?\nYou need to start the same way as in the previous levels.\nTry and get yourself into a situation where you have a\n*hypothesis* `hAB : x \u2208 A \u2229 B` and then use `rw mem_inter_iff at hAB`. \n-/\n\n/- Hint: A note on `x \u2208 A \u2227 x \u2208 B \u2192 x \u2208 A`\nBy convention, \u2227 binds more tightly than \u2192\n(i.e. `x \u2208 A \u2227 x \u2208 B \u2192 x \u2208 A` means `(x \u2208 A \u2227 x \u2208 B) \u2192 x \u2208 A`)\n-/\n\n/- Hint : Reminder about `cases` \nThe `cases h with hP hQ` tactic turns `h : P \u2227 Q` into `hP : P` and `hQ : Q`\n-/\n\n/- Hint : The `tauto!` tactic\nThe `tauto!` tactic solves goals in propositional logic (i.e. problems where\nthe relevant hypotheses and goal just involve `\u2227`, `\u2228`, `\u00ac` and `\u2192` and\npropositions -- for example it could easily solve this goal:\n\n```\nh : P \u2227 Q\n\u22a2 P\n```\n-/\n\n/- Lemma\nIf $A$ and $B$ are sets of any type $X$, then\n$$ A \\cap B \\subseteq A.$$\n-/\ntheorem intersection_subset (A B : set X) : A \u2229 B \u2286 A  :=\nbegin\n", "proof": "  rw subset_iff,\n  intros x hx,\n  rw mem_inter_iff at hx,\n  tauto!, -- or cases, assumption\n\n\n  ", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena -- hide\n", "height": 7, "editorText": "sorry", "lineOffset": 61, "name": "intersection_subset", "statement": "(A B : set X) : A \u2229 B \u2286 A"}, {"type": "lean", "content": "46", "hidden": true}], "url": ""}, {"name": "", "problemIndex": 10, "objects": [{"type": "lean", "content": "47", "hidden": true}, {"type": "lean", "content": "48", "hidden": true}, {"type": "lean", "content": "49", "hidden": true}, {"type": "lean", "content": "50", "hidden": true}, {"type": "text", "content": "51"}, {"type": "axiom", "content": "52", "name": "ext_iff :", "sideBar": true}, {"type": "text", "content": "53"}, {"type": "hint", "content": "54", "title": "55"}, {"type": "hint", "content": "56", "title": "57"}, {"type": "hint", "content": "58", "title": "59"}, {"type": "lemma", "text": "60", "lean": "theorem subset_iff_union_eq (A : set X) (B : set X) : A \u2286 B \u2194 B = A \u222a B := \n", "sideBar": true, "firstProofLineNumber": 83, "lastProofLineNumber": 100, "textBefore": "import game.sets.sets_level03 -- hide\n\nnamespace xena -- hide\n\nopen_locale classical -- hide\n\nvariable X : Type --hide\n\n/-\n# Chapter 1 : Sets\n\n## Level 4\n-/\n\n/- Axiom : ext_iff :\nA = B \u2194 \u2200 x : X, x \u2208 A \u2194 x \u2208 B\n-/\n\n/-\n\nTo prove that two sets are equal, one needs to use the axiom\nof extensionality: two sets are equal if and only if they have\nthe same elements.\n\nIn Lean's maths library this axiom is called `ext_iff`.\n\n```\nlemma ext_diff : A = B \u2194 \u2200 x : X, x \u2208 A \u2194 x \u2208 B\n```\n-/\n\n/- Hint: A word on coding style\n\nAfter a `split` statement, one goal turns into two. A good programming style\nwould be to use `{}` brackets to work on each goal individually, like this:\n```\nbegin\n  split,\n  { insert,\n    proof of,\n    first goal\n  },\n  { insert,\n    proof of,\n    second goal\n  }\nend\n```\n\nThis way you only ever have one goal to work on, and your code becomes\neasier to read. After `split` you might want to write \n```\n{ sorry},\n{ sorry}\n```\nso that your code has no errors while you're working on it.\n-/\n\n\n/- Hint : Stuck?\nTo prove the theorem below, remember that you can use `split` to \nchange the goal into two goals, corresponding to the left-right and\nright-left implication, respectively. For the first goal, after\n`intro h,` the equality of the two sets can be manipulated\nusing `rw ext_iff`.\n-/\n\n/- Hint: rewrite failures and the `simp_rw` tactic\n`rw` doesn't work \"under a binder\". In other words, if your goal is\n`\u22a2\t\u2200 (x : X), x \u2208 B \u2194 x \u2208 A \u222a B` then `rw mem_union_iff` won't work!\nIt's the `\u2200` which is blocking it. Either do `intro x` (and then\nthe `rw` will work), or use a more powerful rewrite tactic\ncalled `simp_rw`, which will work \n\n-/\n\n/- Lemma\nIf $A$ and $B$ are sets of any type $X$, then\n$$ A \\subseteq B \\iff A \\cup B = B.$$\n-/\ntheorem subset_iff_union_eq (A : set X) (B : set X) : A \u2286 B \u2194 B = A \u222a B := \nbegin\n", "proof": "  rw subset_iff,\n  split,\n  { intro h,\n    rw ext_iff,\n     -- can't rewrite under a binder\n    simp_rw mem_union_iff,\n    intro x,\n    specialize h x, -- or replace h := h x,\n    tauto! },\n  { intro h,\n    intros x hA,\n    rw h,\n    rw mem_union_iff,\n    tauto!\n  }\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n--begin hide\n-- theorem subset_iff_union_eq' (A : set X) (B : set X) : A \u2286 B \u2194 B = A \u222a B := \n-- begin\n--   rw subset_iff,\n--   rw ext_iff,\n--   apply forall_congr,\n--   intro x,\n--   rw mem_union_iff,\n--   tauto!,\n-- end\n--end hide\n\n\nend xena --hide\n", "height": 18, "editorText": "sorry", "lineOffset": 82, "name": "subset_iff_union_eq", "statement": "(A : set X) (B : set X) : A \u2286 B \u2194 B = A \u222a B"}, {"type": "lean", "content": "61", "hidden": false}, {"type": "lean", "content": "62", "hidden": true}], "url": ""}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "63", "hidden": true}, {"type": "lean", "content": "64", "hidden": true}, {"type": "lean", "content": "65", "hidden": true}, {"type": "lean", "content": "66", "hidden": true}, {"type": "text", "content": "67"}, {"type": "text", "content": "68"}, {"type": "lemma", "text": "69", "lean": "theorem subset_iff_inter_eq (A : set X) (B : set X) : A \u2286 B \u2194 A = A \u2229 B := \n", "sideBar": true, "firstProofLineNumber": 39, "lastProofLineNumber": 51, "textBefore": "import game.sets.sets_level04 -- hide\n\nnamespace xena -- hide\n\nopen_locale classical -- hide\n\nvariable X : Type --hide\n\n/-\n# Chapter 1 : Sets\n\n## Level 5\n-/\n\n\n/-\nIf `h : \u2200 (x : X), x \u2208 A \u2192 x \u2208 B` then `h` is a function which takes\na term `x` of type `X` as input, and also a proof that `x \u2208 A`, and outputs a\nproof that `x \u2208 B`. If you want to run this function `h` on some term `a : X`\nthen any of the following work:\n\n```\nhave h2 := h a,\nreplace h := h a,\nspecialize h a\n```\n\nThe first one preserves `h` and creates a new hypothesis `h2`. The others\nreplace `h` with `h : a \u2208 A \u2192 a \u2208 B`.\n-/\n\n/- Lemma\nIf $A$ and $B$ are sets of any type $X$, then\n$$ A \\subseteq B \\iff A \\cap B = A.$$\n-/\n\ntheorem subset_iff_inter_eq (A : set X) (B : set X) : A \u2286 B \u2194 A = A \u2229 B := \nbegin\n", "proof": "  rw subset_iff,\n  rw ext_iff,\n  split,\n  { intros h x,\n    specialize h x,\n    rw mem_inter_iff,\n    tauto!\n  },\n  { intros h x hx,\n    specialize h x,\n    rw mem_inter_iff at h,\n    tauto!,\n  }", "proof_hint": "sorry", "textAfter": "\nend\n\n-- begin hide\n-- theorem subset_iff_intersection_eq' (A : set X) (B : set X) : A \u2286 B \u2194 A \u2229 B = A := \n-- begin\n--   rw subset_iff,\n--   rw eq_iff,\n--   apply forall_congr, -- clever trick\n--   intro x,\n--   rw mem_inter_iff, -- no longer under a binder\n--   tauto!\n-- end\n-- end hide\n\nend xena -- hide", "height": 13, "editorText": "sorry", "lineOffset": 38, "name": "subset_iff_inter_eq", "statement": "(A : set X) (B : set X) : A \u2286 B \u2194 A = A \u2229 B"}, {"type": "lean", "content": "70", "hidden": true}, {"type": "lean", "content": "71", "hidden": true}], "url": ""}, {"name": "", "problemIndex": 9, "objects": [{"type": "lean", "content": "72", "hidden": true}, {"type": "lean", "content": "73", "hidden": true}, {"type": "lean", "content": "74", "hidden": true}, {"type": "lean", "content": "75", "hidden": false}, {"type": "lean", "content": "76", "hidden": true}, {"type": "text", "content": "77"}, {"type": "text", "content": "78"}, {"type": "axiom", "content": "79", "name": "mem_sdiff_iff :", "sideBar": true}, {"type": "axiom", "content": "80", "name": "mem_neg_iff :", "sideBar": true}, {"type": "lemma", "text": "81", "lean": "theorem setdiff_eq_intersect_comp (A B : set X) : A \\ B = A \u2229 B\u1d9c := \n", "sideBar": true, "firstProofLineNumber": 53, "lastProofLineNumber": 57, "textBefore": "import game.sets.sets_level05 -- hide\nimport tactic -- hide\n\n\nnamespace xena -- hide\n\nvariable X : Type\n\nopen_locale classical -- hide\n\n/-\n# Chapter 1 : Sets\n\n## Level 6 : `sdiff` and `neg`\n-/\n\n/-\n\nThe set-theoretic difference `A \\ B` satisfies the following property:\n\n```\nlemma mem_sdiff_iff : x \u2208 A \\ B \u2194 x \u2208 A \u2227 x \u2209 B\n```\n\nThe complement `-A` of a set `A` (often denoted $A^c$ in textbooks)\nis all the elements of `X` which are not in `A`:\n\n```\nlemma mem_neg_iff : x \u2208 -A \u2194 x \u2209 A\n```\n\nIn this lemma, you might get a shock. The `rw` tactic is aggressive\nin the Real Number Game -- if after a rewrite the goal can be\nsolved by `refl`, then Lean will close the goal automatically.\n\n-/\n\n/- Axiom : mem_sdiff_iff :\nx \u2208 A \\ B \u2194 x \u2208 A \u2227 x \u2209 B\n-/\n\n/- Axiom : mem_neg_iff :\nx \u2208 -A \u2194 x \u2209 A\n-/\n\n/- Lemma\nIf $A$ and $B$ are sets with elements of type $X$, then\n\n$$(A \\setminus B) = A \\cap B^{c}.$$\n-/\ntheorem setdiff_eq_intersect_comp (A B : set X) : A \\ B = A \u2229 B\u1d9c := \nbegin\n", "proof": "  rw ext_iff,\n  intro x,\n  rw mem_sdiff_iff,\n  rw mem_inter_iff,\n  rw mem_neg_iff,", "proof_hint": "sorry", "textAfter": "\nend\n\n\nend xena -- hide\n", "height": 5, "editorText": "sorry", "lineOffset": 52, "name": "setdiff_eq_intersect_comp", "statement": "(A B : set X) : A \\ B = A \u2229 B\u1d9c"}, {"type": "lean", "content": "82", "hidden": true}], "url": ""}, {"name": "", "problemIndex": 9, "objects": [{"type": "lean", "content": "83", "hidden": true}, {"type": "lean", "content": "84", "hidden": true}, {"type": "lean", "content": "85", "hidden": true}, {"type": "lean", "content": "86", "hidden": true}, {"type": "lean", "content": "87", "hidden": true}, {"type": "text", "content": "88"}, {"type": "text", "content": "89"}, {"type": "axiom", "content": "90", "name": "mem_empty_iff :", "sideBar": true}, {"type": "hint", "content": "91", "title": "92"}, {"type": "lemma", "text": "93", "lean": "theorem empty_set_subset (A : set X) : \u2205 \u2286 A :=\n", "sideBar": true, "firstProofLineNumber": 44, "lastProofLineNumber": 51, "textBefore": "import tactic --hide\n\nimport game.sets.sets_level06 -- hide\n\nvariable X : Type --hide\n\nopen_locale classical -- hide\n\nnamespace xena -- hide\n\n/-\n# Chapter 1 : Sets\n\n## Level 7 : The empty set\n-/\n\n/-\n\nThe way to handle the empty set is the following:\n\n```\nlemma mem_empty_iff (a : X) : a \u2208 (\u2205 : set X) \u2194 false\n```\n-/\n\n/- Axiom : mem_empty_iff :\na \u2208 (\u2205 : set X) \u2194 false\n-/\n\n/- Hint : Stuck?\nRemember that `exfalso` changes any goal to `false`. This can be\nconvenient if your hypotheses can prove `false`.\n\nAnother approach: if `hx : false` then `cases hx` will do a case\nsplit into every proof of false -- but there are no proofs of\nfalse! So there will be no cases left to do.\n-/\n\n/- Lemma\nThe empty set is a subset of any set $A$. \n-/\ntheorem empty_set_subset (A : set X) : \u2205 \u2286 A :=\nbegin\n", "proof": "  rw subset_iff,\n  intros x hx,\n  exfalso,\n  rw mem_empty_iff at hx,\n  exact hx,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena", "height": 8, "editorText": "sorry", "lineOffset": 43, "name": "empty_set_subset", "statement": "(A : set X) : \u2205 \u2286 A"}, {"type": "lean", "content": "94", "hidden": false}], "url": ""}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "95", "hidden": true}, {"type": "text", "content": "96"}, {"type": "text", "content": "97"}, {"type": "axiom", "content": "98", "name": "mem_Icc_iff :", "sideBar": true}, {"type": "text", "content": "99"}, {"type": "lean", "content": "100", "hidden": false}, {"type": "lemma", "text": "101", "lean": "example : (2 : \u211d) \u2208 [(0 : \u211d), 5] := \n", "sideBar": false, "firstProofLineNumber": 55, "lastProofLineNumber": 57, "textBefore": "import kb_real_defs --hide\n\n/-\n# Chapter 1 : Sets\n\n## Level 8\n-/\n\n\n/- \nThis is a very basic example of working with intervals of real numbers in Lean.\nAn interval `[a, b]` that is closed at both endpoints $a$ and $b$ can be \nconstructed using `set.Icc a b`. For an open-closed interval `(a, b]`,\nthe notation\nis `set.Ioc a b`, etc. The usual closed-interval notation, using square\nbrackets, is used here as a wrapper around these definitions. We have\nthe following lemma:\n\n\n\n```\nmem_Icc_iff : x \u2208 Icc a b \u2194 a \u2264 x \u2227 x \u2264 b\n```\n-/\n\n/- Axiom : mem_Icc_iff :\nx \u2208 Icc a b \u2194 a \u2264 x \u2227 x \u2264 b\n-/\n\n/-\nAfter rewriting it, the `split` tactic will isolate the two conditions for \nmembership. Each inequality goals can be solved with the `norm_num` tactic,\nwhich closes goals which are equalities or inequalities between explicit\nreal numbers.\n-/\n\n/- Pro tip : semicolons\nIf instead of a comma, you end a line with a semicolon, then\nLean will apply the next tactic to all the goals created by the\nprevious tactic, rather than just the top one.\n-/\n\n/- Pro tip : definitional equality\n`mem_Icc_iff` is true by definition, so you don't actually\nhave to even rewrite it.\n-/\n\nnotation `[` a `,` b `]`  := set.Icc a b\n\n/- Lemma : no-side-bar\n$2 \u2208 [0,5]$\n-/\nexample : (2 : \u211d) \u2208 [(0 : \u211d), 5] := \nbegin\n", "proof": "    rw mem_Icc_iff,\n    split;\n    norm_num,", "proof_hint": "sorry", "textAfter": "\nend\n\n", "height": 3, "editorText": "sorry", "lineOffset": 54, "name": "", "statement": "(2 : \u211d) \u2208 [(0 : \u211d), 5]"}], "url": ""}, {"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "102", "hidden": false}, {"type": "text", "content": "103"}, {"type": "text", "content": "104"}, {"type": "lean", "content": "105", "hidden": false}, {"type": "lemma", "text": "106", "lean": "lemma zero_in_prod : (0:\u211d) \u2208 mem_prod_sets [(-2:\u211d), -1] [(0:\u211d), 3] :=\n", "sideBar": true, "firstProofLineNumber": 24, "lastProofLineNumber": 36, "textBefore": "import kb_real_defs\n\n/-\n# Chapter 1 : Sets\n\n## Level 9\n-/\n\n/- \nThis is a little more complicated example asking you to work with intervals of reals.\nThe result will be of help in the sup-inf world.\n-/\n\nnotation `[` a `,` b `]`  := set.Icc a b\n\ndef mem_prod_sets (A : set \u211d) (B : set \u211d) := { x : \u211d | \u2203 y \u2208 A, \u2203 z \u2208 B, x = y * z}\n\n\n/- Lemma\nIf $x = 0$, then `x \u2208 mem_prod_sets [(-2:\u211d),-1] [(0:\u211d), 3]`\n-/\nlemma zero_in_prod : (0:\u211d) \u2208 mem_prod_sets [(-2:\u211d), -1] [(0:\u211d), 3] :=\nbegin\n", "proof": "  rw mem_prod_sets,\n  dsimp,\n  use -2,\n  split, \n  { rw mem_Icc_iff,\n    split; linarith\n  },\n  use 0,\n  split,\n  { rw mem_Icc_iff,\n    split; linarith\n  },\n  norm_num", "proof_hint": "sorry", "textAfter": "\nend\n\n\n", "height": 13, "editorText": "sorry", "lineOffset": 23, "name": "zero_in_prod", "statement": "(0:\u211d) \u2208 mem_prod_sets [(-2:\u211d), -1] [(0:\u211d), 3]"}], "url": ""}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "107", "hidden": false}, {"type": "text", "content": "108"}, {"type": "axiom", "content": "109", "name": "inv_prod_self :", "sideBar": true}, {"type": "axiom", "content": "110", "name": "inv_prod_other :", "sideBar": true}, {"type": "axiom", "content": "111", "name": "archimedean_R : \u2200 x : \u211d, 0 < x \u2192 \u2203 n : \u2115, 0 < n \u2227 (1/n : \u211d) < x", "sideBar": true}, {"type": "axiom", "content": "112", "name": "has_ceiling : \u2200 x : \u211d,  \u2203 m : \u2124, ((m-1) : \u211d) \u2264 x \u2227 x < (m:\u211d)", "sideBar": true}, {"type": "lean", "content": "113", "hidden": false}, {"type": "lean", "content": "114", "hidden": true}, {"type": "lemma", "text": "115", "lean": "theorem rat_dense_in_R : dense_in_R embedded_rationals := \n", "sideBar": true, "firstProofLineNumber": 50, "lastProofLineNumber": 103, "textBefore": "import data.real.basic\n\n/-\n# Chapter 1 : Sets\n\n## Level 10\n\nAs a final test of your ability in working with sets, prove that the set of rational \nnumbers is dense in the reals.\n\nThis proof will, among other things, rely on several new axioms that appear\nin the left side bar.\nNote that you may need to change the type of some quantities from rationals to reals.\nLean doesn't necessarily consider the rational $2$ to be the same at the real number $2$.\nSome of the axioms on the left make working with the casts from rationals to reals easier.\n-/\n\n\n/- Axiom : inv_prod_self : \n\u2200 n : \u2115, 0 < n \u2192 (1/n : \u211d) * (n : \u211d ) = 1 \n-/\n\n/- Axiom : inv_prod_other : \n\u2200 (m : \u2124), \u2200 (n : \u2115), 0 < n \u2192 (1/n : \u211d) * (m : \u211d) = (m/n : \u211d)\n-/\n\n/- Axiom : archimedean_R : \u2200 x : \u211d, 0 < x \u2192 \u2203 n : \u2115, 0 < n \u2227 (1/n : \u211d) < x\n-/\n\n/- Axiom : has_ceiling : \u2200 x : \u211d,  \u2203 m : \u2124, ((m-1) : \u211d) \u2264 x \u2227 x < (m:\u211d)\n-/\n\n-- one way to prove \u211a dense in \u211d \ndef dense_in_R (A : set \u211d) := \u2200 (x y : \u211d), x < y \u2192 \u2203 a \u2208 A, a \u2208 set.Ioo x y\ndef embedded_rationals : set \u211d := { x | \u2203 r : \u211a, x = \u2191r }\n-- begin hide\naxiom archimedean_R : \u2200 x : \u211d, 0 < x \u2192 \u2203 n : \u2115, 0 < n \u2227 (1/n : \u211d) < x\n-- we might want to prove these below. Made into axioms just for ease.\n-- the problem is that the proofs are too hard for this level, IMO (DS)\naxiom has_ceiling : \u2200 x : \u211d,  \u2203 m : \u2124, ((m-1) : \u211d) \u2264 x \u2227 x < (m:\u211d)\naxiom inv_prod_self : \u2200 n : \u2115, 0 < n \u2192 (1/n : \u211d) * (n : \u211d ) = 1 \naxiom inv_prod_other : \u2200 (m : \u2124), \u2200 (n : \u2115), 0 < n \u2192 (1/n : \u211d) * (m : \u211d) = (m/n : \u211d)\n-- end hide\n\n/- Lemma\nRationals are dense in the reals.\n-/\ntheorem rat_dense_in_R : dense_in_R embedded_rationals := \nbegin\n", "proof": "    intros x y hxy,\n    have H := lt_trichotomy x 0,\n    cases H with xL xr, swap, cases xr with x0 xR,\n    -- case x = 0\n    rw x0 at hxy, \n    have G := archimedean_R y hxy,\n    cases G with n hn, cases hn with hnL hnR,\n    use (1/n), split, existsi (1/n : \u211a), norm_num,\n    split, swap, exact hnR, rw x0, norm_num, exact hnL,\n    -- case 0 < x\n    have H : 0 < y - x, linarith,\n    have G := archimedean_R (y-x) H,\n    cases G with n hn, cases hn with hnL hnR, \n    have F := has_ceiling (n*x),\n    cases F with m hm, cases hm with hmL hmR,\n    use (m/n), split, existsi (m/n : \u211a), norm_num,\n    have hnL1 : 0 < (n : \u211d), norm_cast, exact hnL, \n    have hnL2 : 0 < (1/n : \u211d), exact one_div_pos_of_pos hnL1,\n    split, exact (lt_div_iff' hnL1).mpr hmR,\n    have h1 : (m : \u211d) \u2264 n*x + 1, linarith,\n    have h2 : (m/n : \u211d) \u2264 x + (1/n : \u211d), \n        have h21 := (mul_le_mul_left hnL2).mpr h1, \n        rw mul_add (1/n : \u211d) _ _ at h21, rw mul_one at h21,\n        rw \u2190 mul_assoc at h21, \n        have h22 := inv_prod_self n hnL,    --cheating here\n        rw h22 at h21, rw one_mul at h21,\n        have h23 := inv_prod_other m n hnL, --and here\n        rw h23 at h21, exact h21,\n    have h3 : x + (1/n : \u211d) < x + (y-x), linarith,\n    have h4 : x + (y-x) = y, norm_num, rw h4 at h3,\n    linarith, \n    -- case x < 0  -- reduces to the above\n     have H : 0 < y - x, linarith,\n    have G := archimedean_R (y-x) H,\n    cases G with n hn, cases hn with hnL hnR, \n    have F := has_ceiling (n*x),\n    cases F with m hm, cases hm with hmL hmR,\n    use (m/n), split, existsi (m/n : \u211a), norm_num,\n    have hnL1 : 0 < (n : \u211d), norm_cast, exact hnL, \n    have hnL2 : 0 < (1/n : \u211d), exact one_div_pos_of_pos hnL1,\n    split, exact (lt_div_iff' hnL1).mpr hmR,\n    have h1 : (m : \u211d) \u2264 n*x + 1, linarith,\n    have h1 : (m : \u211d) \u2264 n*x + 1, linarith,\n    have h2 : (m/n : \u211d) \u2264 x + (1/n : \u211d), \n        have h21 := (mul_le_mul_left hnL2).mpr h1, \n        rw mul_add (1/n : \u211d) _ _ at h21, rw mul_one at h21,\n        rw \u2190 mul_assoc at h21, \n        have h22 := inv_prod_self n hnL,    --cheating here\n        rw h22 at h21, rw one_mul at h21,\n        have h23 := inv_prod_other m n hnL, --and here\n        rw h23 at h21, exact h21,\n    have h3 : x + (1/n : \u211d) < x + (y-x), linarith,\n    have h4 : x + (y-x) = y, norm_num, rw h4 at h3,\n    linarith, done", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 54, "editorText": "sorry", "lineOffset": 49, "name": "rat_dense_in_R", "statement": "dense_in_R embedded_rationals"}], "url": ""}]}, {"name": "116", "levels": [{"name": "", "problemIndex": 3, "objects": [{"type": "lean", "content": "117", "hidden": false}, {"type": "lean", "content": "118", "hidden": true}, {"type": "text", "content": "119"}, {"type": "lemma", "text": "120", "lean": "theorem trichotomy' (a b : \u211d) : a < b \u2228 a = b \u2228 b < a :=\n", "sideBar": true, "firstProofLineNumber": 27, "lastProofLineNumber": 27, "textBefore": "import game.sets.sets_level10\nimport data.real.basic\n\nnamespace xena -- hide\n\n/-\n# Chapter 2 : Order\n\n## Level 1\n\nThis level aims to familiarize you with the use of the trichotomy property in \nLean, as it will come in handy in later levels.\nThis property is stated in Lean's mathlib is:\n\n`lt_trichotomy : \u2200 (a b : ?M_1), a < b \u2228 a = b \u2228 b < a`\n\nand you can just use it to finish the proof below.\n-/\n\n\n/- Lemma\nFor any two real numbers $a$ and $b$, we have that\n$$ a < b \\lor a = b \\lor b < a$$.\n-/\ntheorem trichotomy' (a b : \u211d) : a < b \u2228 a = b \u2228 b < a :=\nbegin\n", "proof": "    exact lt_trichotomy a b, done", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena --hide\n", "height": 1, "editorText": "sorry", "lineOffset": 26, "name": "trichotomy'", "statement": "(a b : \u211d) : a < b \u2228 a = b \u2228 b < a"}, {"type": "lean", "content": "121", "hidden": true}], "url": ""}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "122", "hidden": false}, {"type": "lean", "content": "123", "hidden": true}, {"type": "text", "content": "124"}, {"type": "hint", "content": "125", "title": "126"}, {"type": "text", "content": "127"}, {"type": "lean", "content": "128", "hidden": false}, {"type": "lemma", "text": "129", "lean": "theorem abs_prod (a b : \u211d) : |a * b| = |a| * |b| :=\n", "sideBar": true, "firstProofLineNumber": 31, "lastProofLineNumber": 90, "textBefore": "import data.real.basic\nimport game.order.level01\n\nnamespace xena -- hide\n\n/-\n# Chapter 2 : Order\n\n## Level 2\n\nThis level invites you to work out a property of the absolute value.\nIn Lean the absolute value of $x$ is denoted by `abs x`. \n-/\n\n/- Hint : The definition of the absolute value in mathlib:\ndefinition abs {\u03b1 : Type u} [decidable_linear_ordered_add_comm_group \u03b1] (a : \u03b1) : \u03b1 := max a (-a)\n-/\n\n/-\nFor ease of use, a notation can be wrapped around that definition as below.\n-/\n\nnotation `|` x `|` := abs x\n\n/- Lemma\nFor any two real numbers $a$ and $b$, we have that\n$$|ab| = |a||b|$$.\n-/\ntheorem abs_prod (a b : \u211d) : |a * b| = |a| * |b| :=\nbegin\n", "proof": "    rcases lt_trichotomy a 0 with haNeg | haZero | haPos,\n    swap,\n    { -- case a = 0\n        have h1 : a * b = 0, norm_num, left, exact haZero,\n        have h2 : | a * b | = 0, exact (is_absolute_value.abv_eq_zero abs).mpr h1,\n        have h3 : | a | = 0, exact (is_absolute_value.abv_eq_zero abs).mpr haZero,\n        rw [h2,h3], norm_num,\n    },\n    { -- case a < 0\n        rcases lt_trichotomy b 0 with hbNeg | hbZero | hbPos,\n        swap,\n        { -- case b = 0\n            have h1 : a * b = 0, norm_num, right, exact hbZero,\n            have h2 : | a * b | = 0, exact (is_absolute_value.abv_eq_zero abs).mpr h1,\n            have h3 : | b | = 0, exact (is_absolute_value.abv_eq_zero abs).mpr hbZero,\n            rw [h2,h3], norm_num,\n        },\n        { -- case b < 0\n            have h1 : 0 < a * b,  exact mul_pos_of_neg_of_neg haNeg hbNeg,\n            have h2 : | a * b | = a * b, exact abs_of_pos h1,\n            have h3 : | a | = - a, exact abs_of_neg haNeg,\n            have h4 : | b | = - b, exact abs_of_neg hbNeg,\n            rw [h2, h3, h4], norm_num,\n        },\n        { -- case 0 < b\n            have h1 : a * b < 0,  exact mul_neg_of_neg_of_pos haNeg hbPos,\n            have h2 : | a * b | = - (a * b), exact abs_of_neg h1,\n            have h3 : | a | = - a, exact abs_of_neg haNeg,\n            have h4 : | b | = b, exact abs_of_pos hbPos,\n            rw [h2, h3, h4], norm_num,\n        }\n\n    },\n    { -- case 0 < a\n        rcases lt_trichotomy b 0 with hbNeg | hbZero | hbPos,\n        swap,\n        { -- case b = 0\n            have h1 : a * b = 0, norm_num, right, exact hbZero,\n            have h2 : | a * b | = 0, exact (is_absolute_value.abv_eq_zero abs).mpr h1,\n            have h3 : | b | = 0, exact (is_absolute_value.abv_eq_zero abs).mpr hbZero,\n            rw [h2,h3], norm_num,\n        },\n        { -- case b < 0\n            have h1 : a * b < 0,  exact mul_neg_of_pos_of_neg haPos hbNeg,\n            have h2 : | a * b | = -( a * b), exact abs_of_neg h1,\n            have h3 : | a | = a, exact abs_of_pos haPos,\n            have h4 : | b | = - b, exact abs_of_neg hbNeg,\n            rw [h2, h3, h4], norm_num,\n        },\n        { -- case 0 < b\n            have h1 : 0 < a * b,  exact mul_pos haPos hbPos,\n            have h2 : | a * b | = a * b, exact abs_of_pos h1,\n            have h3 : | a | = a, exact abs_of_pos haPos,\n            have h4 : | b | = b, exact abs_of_pos hbPos,\n            rw [h2, h3, h4],  -- this is enough, rw closes the refl goal \n        }\n\n    },\n    done\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena --hide\n", "height": 60, "editorText": "sorry", "lineOffset": 30, "name": "abs_prod", "statement": "(a b : \u211d) : |a * b| = |a| * |b|"}, {"type": "lean", "content": "130", "hidden": true}], "url": ""}, {"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "131", "hidden": false}, {"type": "lean", "content": "132", "hidden": true}, {"type": "text", "content": "133"}, {"type": "lean", "content": "134", "hidden": true}, {"type": "lemma", "text": "135", "lean": "theorem abs_le (a c : \u211d) (h : 0 \u2264 c): |a| \u2264 c \u2194 (-c) \u2264 a \u2227 a \u2264 c :=\n", "sideBar": true, "firstProofLineNumber": 21, "lastProofLineNumber": 55, "textBefore": "import game.order.level02\n\nnamespace xena -- hide\n\n/-\n# Chapter 2 : Order\n\n## Level 3\n\nAnother property of the absolute value.\n-/\n\nnotation `|` x `|` := abs x --hide\n\n/- Lemma\nFor any two real numbers $a$ and $b$, we have that\n$$|a| \u2264 c \u2194 -c \u2264 a \u2264 c$$.\n-/\ntheorem abs_le (a c : \u211d) (h : 0 \u2264 c): |a| \u2264 c \u2194 (-c) \u2264 a \u2227 a \u2264 c :=\nbegin\n", "proof": "split,\n    rcases lt_trichotomy a 0 with haNeg | haZero | haPos,\n    { -- case a < 0\n        intro H, \n        have h1 : | a | = - a, exact abs_of_neg haNeg,\n        rw h1 at H, split, linarith, linarith,\n    },\n    { -- case a = 0\n        intro H, rw haZero, split, linarith, exact h,\n    },\n    { -- case 0 < a\n        intro H,\n        have h1 : |a| = a, exact abs_of_pos haPos,\n        rw h1 at H, split, linarith, exact H,\n    },\n    \n    \n    rcases lt_trichotomy a 0 with haNeg | haZero | haPos,\n    { -- case a < 0\n        intro H, \n        have h1 : | a | = - a, exact abs_of_neg haNeg,\n        rw abs_le, \n        exact H,\n    },\n    { -- case a = 0\n        intro H,\n        rw abs_le, exact H,\n    },\n    { -- case 0 < a\n        intro H,\n        rw abs_le, exact H,\n    },\n    \n\n    done", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena --hide\n\n", "height": 35, "editorText": "sorry", "lineOffset": 20, "name": "abs_le", "statement": "(a c : \u211d) (h : 0 \u2264 c): |a| \u2264 c \u2194 (-c) \u2264 a \u2227 a \u2264 c"}, {"type": "lean", "content": "136", "hidden": true}], "url": ""}, {"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "137", "hidden": false}, {"type": "lean", "content": "138", "hidden": true}, {"type": "text", "content": "139"}, {"type": "lean", "content": "140", "hidden": false}, {"type": "lemma", "text": "141", "lean": "theorem abs_sub_le_sum_abs (a b : \u211d) : |a - b| \u2264 |a| + |b| :=\n", "sideBar": true, "firstProofLineNumber": 28, "lastProofLineNumber": 32, "textBefore": "import game.order.level03\n\nnamespace xena -- hide\n\n/-\n# Chapter 2 : Order\n\n## Level 4\n\nThis level invites you to work out a property of the absolute value.\nIn Lean the absolute value of $x$ is denoted by `abs x`. \nFor ease of use, a notation can be used around that definition as below.\nFeel free to use the triangle inequality on the real numbers,\n\n`abs_add : \u2200 (a b : ?M_1), |a + b| \u2264 |a| + |b|`\n\ntogether with the `linarith` and `norm_num` tactics.\n-/\n\nnotation `|` x `|` := abs x\n\n/- Lemma\nFor any two real numbers $a$ and $b$, we have that\n$$| a - b| \u2264 |a| + |b|$$.\n-/\ntheorem abs_sub_le_sum_abs (a b : \u211d) : |a - b| \u2264 |a| + |b| :=\nbegin\n", "proof": "    have H : a - b = a + (-b), linarith,\n    rw H, \n    have G := abs_add a (-b),\n    have F : abs (-b) = abs b, norm_num,\n    rw F at G, exact G, done", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena --hide\n", "height": 5, "editorText": "sorry", "lineOffset": 27, "name": "abs_sub_le_sum_abs", "statement": "(a b : \u211d) : |a - b| \u2264 |a| + |b|"}, {"type": "lean", "content": "142", "hidden": true}], "url": ""}, {"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "143", "hidden": false}, {"type": "lean", "content": "144", "hidden": true}, {"type": "text", "content": "145"}, {"type": "lean", "content": "146", "hidden": true}, {"type": "lemma", "text": "147", "lean": "theorem abs_of_sub_le_abs (a b : \u211d) : | |a| - |b| | \u2264 |a - b| :=\n", "sideBar": true, "firstProofLineNumber": 21, "lastProofLineNumber": 44, "textBefore": "import game.order.level04\n\nnamespace xena -- hide\n\n/-\n# Chapter 2 : Order\n\n## Level 5\n\nAnother well-known property of the absolute value.\n-/\n\nnotation `|` x `|` := abs x -- hide\n\n/- Lemma\nFor any two real numbers $a$ and $b$, we have that\n$$| |a| - |b| | \u2264 |a - b|$$.\n-/\ntheorem abs_of_sub_le_abs (a b : \u211d) : | |a| - |b| | \u2264 |a - b| :=\nbegin\n", "proof": "    have h1 : a = (a - b) + b, norm_num,\n    have h2 : |a| = |(a-b) + b|, rw h1, simp,\n    have h3 : |(a-b) + b | \u2264 |a-b| + |b|, exact abs_add _ _,\n    rw \u2190 h2 at h3,\n    have h4a : |a| - |b| \u2264 |a - b|, linarith,\n    clear h1 h2 h3,\n    have h1 : b = (b - a) + a, norm_num,\n    have h2 : |b| = |(b-a) + a|, rw h1, simp,\n    have h3 : |(b-a) + a | \u2264 |b-a| + |a|, exact abs_add _ _,\n    rw \u2190 h2 at h3,\n    have h4b : |b| - |a| \u2264 |b - a|, linarith, \n    clear h1 h2 h3,\n    have h1 := eq.symm ( abs_neg (a-b) ),\n    have h2 : -(a-b) = b - a, norm_num,\n    rw h2 at h1, clear h2,\n    rw \u2190 h1 at h4b, clear h1,\n    have H : max ( |a| - |b| ) ( |b| - |a| ) \u2264 | a - b |, \n        simp, split, exact h4a, exact h4b,\n    unfold abs,\n    unfold abs at H, \n    have G: -(max a (-a) - max b (-b)) = max b (-b) - max a (-a),\n        norm_num,\n    rw G,\n    exact H, done,", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena --hide\n", "height": 24, "editorText": "sorry", "lineOffset": 20, "name": "abs_of_sub_le_abs", "statement": "(a b : \u211d) : | |a| - |b| | \u2264 |a - b|"}, {"type": "lean", "content": "148", "hidden": true}], "url": ""}, {"name": "", "problemIndex": 3, "objects": [{"type": "lean", "content": "149", "hidden": false}, {"type": "lean", "content": "150", "hidden": true}, {"type": "text", "content": "151"}, {"type": "lemma", "text": "152", "lean": "theorem le_iff_sq_le (a b : \u211d) (ha : 0 \u2264 a) (hb : 0 \u2264 b): a \u2264 b \u2194 a^2 \u2264 b^2:=\n", "sideBar": true, "firstProofLineNumber": 23, "lastProofLineNumber": 44, "textBefore": "import game.order.level05\nimport data.real.basic\nopen real\n\nnamespace xena -- hide\n\n/-\n# Chapter 2 : Order\n\n## Level 6\n\nAn interesting result to prove.\n-/\n\n\n\n/- Lemma\nFor any two non-negative real numbers $a$ and $b$, we have that\n$$a \\le b \\iff a^2 \\le b^2 $$.\n-/\ntheorem le_iff_sq_le (a b : \u211d) (ha : 0 \u2264 a) (hb : 0 \u2264 b): a \u2264 b \u2194 a^2 \u2264 b^2:=\nbegin\n", "proof": "    split,\n    intro h,\n    have h1 : a^2 \u2264 a * b, \n        have h11 : a \u2264 a, linarith,\n        have h12 := mul_le_mul h11 h ha ha,\n        have h13 : a * a = a^2, ring,\n        rw h13 at h12, exact h12,\n    have h2 : a * b \u2264 b^2, \n        have h21 : b \u2264 b, linarith,\n        have h22 := mul_le_mul h21 h ha hb,\n        rw mul_comm at h22,\n        have h23 : b * b = b^2, ring,\n        rw h23 at h22, exact h22,\n    exact le_trans h1 h2,\n    intro h,\n    have ha2 : 0 \u2264 a^2, exact pow_nonneg ha 2,\n    have hb2 : 0 \u2264 b^2, exact pow_nonneg hb 2,\n    have h1 := (sqrt_le ha2 hb2).mpr h,\n    have h2a := sqrt_sqr ha, \n    have h2b := sqrt_sqr hb,\n    rw h2a at h1, rw h2b at h1, exact h1, done\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena -- hide", "height": 22, "editorText": "sorry", "lineOffset": 22, "name": "le_iff_sq_le", "statement": "(a b : \u211d) (ha : 0 \u2264 a) (hb : 0 \u2264 b): a \u2264 b \u2194 a^2 \u2264 b^2"}, {"type": "lean", "content": "153", "hidden": true}], "url": ""}, {"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "154", "hidden": false}, {"type": "lean", "content": "155", "hidden": true}, {"type": "text", "content": "156"}, {"type": "axiom", "content": "157", "name": "irrational_sqrt_two : irrational (sqrt 2)", "sideBar": true}, {"type": "lemma", "text": "158", "lean": "theorem not_sum_irrational : \n    \u00ac ( \u2200 (a b : \u211d), irrational a \u2192  irrational b \u2192 irrational (a+b) ) :=\n", "sideBar": true, "firstProofLineNumber": 34, "lastProofLineNumber": 39, "textBefore": "import game.order.level06\nimport data.real.irrational\n\nopen real\n\nnamespace xena -- hide\n\n/-\n# Chapter 2 : Order\n\n## Level 7\n\nProve by example that there exist pairs of real numbers\n$a$ and $b$ such that $a \\in \\mathbb{R} \\setminus \\mathbb{Q}$, \n$b \\in \\mathbb{R} \\setminus \\mathbb{Q}$,\nbut their sum $a + b$ is a rational number, $(a+b) \\in \\mathbb{Q}$.\nYou may use this result in the Lean mathlib library:\n\n`irrational_sqrt_two : irrational (sqrt 2)`\n\n-/\n\n/- Axiom : irrational_sqrt_two : irrational (sqrt 2)\n-/\n\n\n/- Lemma\nNot true that for any $a$, $b$, irrational numbers, the sum is \nalso an irrational number.\n-/\ntheorem not_sum_irrational : \n    \u00ac ( \u2200 (a b : \u211d), irrational a \u2192  irrational b \u2192 irrational (a+b) ) :=\nbegin\n", "proof": "  intro H,\n  have H2 := H (sqrt 2) (-sqrt 2),\n  have H3 := H2 irrational_sqrt_two (irrational_neg_iff.2 irrational_sqrt_two),\n  apply H3,\n  existsi (0 : \u211a),\n  simp, done", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena -- hide\n", "height": 6, "editorText": "sorry", "lineOffset": 33, "name": "not_sum_irrational", "statement": "\u00ac ( \u2200 (a b : \u211d), irrational a \u2192  irrational b \u2192 irrational (a+b) )"}, {"type": "lean", "content": "159", "hidden": true}], "url": ""}, {"name": "", "problemIndex": 3, "objects": [{"type": "lean", "content": "160", "hidden": false}, {"type": "lean", "content": "161", "hidden": true}, {"type": "text", "content": "162"}, {"type": "lemma", "text": "163", "lean": "theorem not_prod_irrational : \n    \u00ac ( \u2200 (a b : \u211d), irrational a \u2192  irrational b \u2192 irrational (a*b) ) :=\n", "sideBar": true, "firstProofLineNumber": 30, "lastProofLineNumber": 35, "textBefore": "import game.order.level07\nimport data.real.irrational\n\nopen real\n\nnamespace xena -- hide\n\n/-\n# Chapter 2 : Order\n\n## Level 8\n\nProve by example that there exist pairs of real numbers\n$a$ and $b$ such that $a \\in \\mathbb{R} \\setminus \\mathbb{Q}$, \n$b \\in \\mathbb{R} \\setminus \\mathbb{Q}$,\nbut their product $a \\cdot b$ is a rational number, $(a \\cdot b) \\in \\mathbb{Q}$.\nYou may use this result in the Lean mathlib library:\n\n`irrational_sqrt_two : irrational (sqrt 2)\n-/\n\n\n/- Lemma\nNot true that for any $a$, $b$, irrational numbers, the product is \nalso an irrational number.\n-/\ntheorem not_prod_irrational : \n    \u00ac ( \u2200 (a b : \u211d), irrational a \u2192  irrational b \u2192 irrational (a*b) ) :=\nbegin\n", "proof": "  intro H,\n  have H2 := H (sqrt 2) (sqrt 2),\n  have H3 := H2 irrational_sqrt_two irrational_sqrt_two,\n  apply H3,\n  existsi (2 : \u211a),\n  simp, norm_num, done", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena -- hide\n", "height": 6, "editorText": "sorry", "lineOffset": 29, "name": "not_prod_irrational", "statement": "\u00ac ( \u2200 (a b : \u211d), irrational a \u2192  irrational b \u2192 irrational (a*b) )"}, {"type": "lean", "content": "164", "hidden": true}], "url": ""}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "165", "hidden": false}, {"type": "lean", "content": "166", "hidden": true}, {"type": "text", "content": "167"}, {"type": "lean", "content": "168", "hidden": false}, {"type": "lean", "content": "169", "hidden": true}, {"type": "lemma", "text": "170", "lean": "theorem abs_sub_eq_sum_abs (a b : \u211d) : |a + b| = |a| + |b| \u2194 a * b \u2265 0 :=\n", "sideBar": true, "firstProofLineNumber": 42, "lastProofLineNumber": 80, "textBefore": "import game.order.level08\nopen real\n\nnamespace xena -- hide\n\n/-\n# Chapter 2 : Order\n\n## Level 9\n\nThis level invites you to work out a property of the absolute value.\nIn Lean the absolute value of $x$ is denoted by `abs x`. \nFor ease of use, a notation can be used around that definition as below.\nFeel free to use the triangle inequality on the real numbers,\n\n`abs_add : \u2200 (a b : ?M_1), |a + b| \u2264 |a| + |b|`\n\ntogether with the `linarith` and `norm_num` tactics.\n-/\n\nnotation `|` x `|` := abs x\n\n-- begin hide\n-- this to go in the side bar\nlemma eq_sqr_to_eq (a b : \u211d) (ha : 0 \u2264 a) (hb : 0 \u2264 b) : a^2 = b^2 \u2192 a = b :=\nbegin\n    intro H,\n    have A : sqrt (a ^ 2) = sqrt (a ^ 2), refl,\n    rw H at A {occs := occurrences.pos [2]},\n    have G := sqrt_sqr ha, rw G at A,\n    have F := sqrt_sqr hb, rw F at A, \n    exact A, done\nend\n-- end hide\n\n/- Lemma\nFor any two real numbers $a$ and $b$, we have that\n$$|a + b| = |a| + |b|$$ if and only if $ab \\ge 0$ .\n-/\ntheorem abs_sub_eq_sum_abs (a b : \u211d) : |a + b| = |a| + |b| \u2194 a * b \u2265 0 :=\nbegin\n", "proof": "    have H0 : (a+b)^2 = |a+b|^2, \n        have h01 := abs_mul_abs_self (a+b),\n        rw pow_two _, rw pow_two _, symmetry, exact h01,\n    have H1 : 0 \u2264 (a + b) ^ 2, exact pow_two_nonneg (a+b),\n    have H2 : (a+b) ^ 2 = a ^2 + 2 * a * b + b^2, ring,\n    have H3 : ( |a| + |b| )^2 = |a|^2 + 2*|a|*|b| + |b|^2, ring,\n    rw H0 at H2,\n    have Ha : a^2 = |a|^2, \n        have h01 := abs_mul_abs_self a,\n        rw pow_two _, rw pow_two _, symmetry, exact h01,\n    have Hb : b^2 = |b|^2, \n        have h01 := abs_mul_abs_self b,\n        rw pow_two _, rw pow_two _, symmetry, exact h01,\n    rw [Ha, Hb] at H2,\n    split,\n    intro h,\n    rw h at H2, rw H3 at H2, simp at H2, \n    rw mul_assoc at H2, rw mul_assoc at H2,\n    have g1 : ( |a| * |b| ) = (a * b), linarith,\n    have g2 : |a * b| = ( |a| * |b| ), exact abs_mul _ _, \n    rw \u2190 g2 at g1,\n    by_contradiction hn, push_neg at hn,\n    have g3 : | a * b | = - (a *b), exact abs_of_neg hn,\n    rw g1 at g3, linarith,\n    -- the right-left direction\n    intro h,\n    have g1 : |a * b| = a * b, exact abs_of_nonneg h,\n    have g2 : |a * b| = ( |a| * |b| ), exact abs_mul _ _,\n    rw g2 at g1, rw mul_assoc 2 a b at H2,\n    rw \u2190 g1 at H2,\n    have g3 : |a| ^ 2 + 2 * ( |a| * |b| ) + |b| ^ 2 = ( |a| + |b| )^2, ring,\n    rw g3 at H2,\n    have g4 : sqrt ( |a + b| ^ 2 ) = sqrt ( |a + b| ^ 2), refl,\n    rw H2 at g4 {occs := occurrences.pos [2]},\n    have hab : 0 \u2264 |a + b|,  exact is_absolute_value.abv_nonneg abs (a+b),\n    have ha : 0 \u2264 |a|,  exact is_absolute_value.abv_nonneg abs a,\n    have hb : 0 \u2264 |b|,  exact is_absolute_value.abv_nonneg abs b,\n    have hc : 0 \u2264 |a| + |b|, linarith,\n    have G := eq_sqr_to_eq ( |a + b| ) ( |a| + |b| ) hab hc H2, exact G, done", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena -- hide\n\n", "height": 39, "editorText": "sorry", "lineOffset": 41, "name": "abs_sub_eq_sum_abs", "statement": "(a b : \u211d) : |a + b| = |a| + |b| \u2194 a * b \u2265 0"}, {"type": "lean", "content": "171", "hidden": true}], "url": ""}], "parents": [0]}, {"name": "172", "levels": [{"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "173", "hidden": false}, {"type": "lean", "content": "174", "hidden": true}, {"type": "lean", "content": "175", "hidden": false}, {"type": "text", "content": "176"}, {"type": "text", "content": "177"}, {"type": "lean", "content": "178", "hidden": false}, {"type": "text", "content": "179"}, {"type": "lemma", "text": "180", "lean": "lemma upper_bounds_mono (X Y : set \u211d) (h1 : X \u2286 Y) (b : \u211d) : is_upper_bound Y b \u2192 is_upper_bound X b :=\n", "sideBar": true, "firstProofLineNumber": 36, "lastProofLineNumber": 43, "textBefore": "import game.order.level09\nimport data.real.basic -- imports the real numbers \u211d\n\nnamespace xena -- hide\n\n-- World name : Sup and Inf\n\n/-\n# Chapter 3 : Sup and Inf\n\n## Level 1 : Upper bounds\n-/\n\n/-\nLet $X$ be a set of real numbers.\n\nWe say a real number $b$ is an *upper bound* for $X$ if every $x \\in X$ is at most $b$.\n-/\n\ndefinition is_upper_bound (S : set \u211d) (x : \u211d) := \u2200 s \u2208 S, s \u2264 x \n\n/-\nHere is an easy fact about upper bounds, which we shall prove below: \nIf $X \\subseteq Y$ are two sets of reals, and $b$ is an upper bound for $Y$, \nthen it's also an upper bound for $X$.\n\nYou can prove this easily in Lean using the `change` tactic. \n-/\n\n/- Lemma\nIf $X \\subseteq Y$ are two sets of reals, and $b$ is an upper bound for $Y$, \nthen it's also an upper bound for $X$.\n-/\nlemma upper_bounds_mono (X Y : set \u211d) (h1 : X \u2286 Y) (b : \u211d) : is_upper_bound Y b \u2192 is_upper_bound X b :=\nbegin\n", "proof": "  intro h2,\n  intro a,\n  intro ha,\n  apply h2,\n  change \u2200 a, a \u2208 X \u2192 a \u2208 Y at h1,\n--  unfold has_subset.subset set.subset at h1,\n  apply h1,\n  exact ha,", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena -- hide\n", "height": 8, "editorText": "sorry", "lineOffset": 35, "name": "upper_bounds_mono", "statement": "(X Y : set \u211d) (h1 : X \u2286 Y) (b : \u211d) : is_upper_bound Y b \u2192 is_upper_bound X b"}, {"type": "lean", "content": "181", "hidden": true}], "url": ""}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "182", "hidden": false}, {"type": "lean", "content": "183", "hidden": true}, {"type": "lean", "content": "184", "hidden": false}, {"type": "text", "content": "185"}, {"type": "text", "content": "186"}, {"type": "lean", "content": "187", "hidden": false}, {"type": "lean", "content": "188", "hidden": true}, {"type": "lemma", "text": "189", "lean": "theorem nonempty_and_bounded_of_has_LUB (S : set \u211d) (H : has_lub S) : \n  (S \u2260 \u2205) \u2227 (\u2203 x, is_upper_bound S x) :=\n", "sideBar": true, "firstProofLineNumber": 38, "lastProofLineNumber": 59, "textBefore": "import game.sup_inf.level01\n\nnamespace xena -- hide\n-- World name : Sup and Inf\n\n/-\n# Chapter 3 : Sup and Inf\n\n## Level 2  \n\n-/\n\n/-\nThe completeness axiom on the reals states that any non-empty subset \n$X \\subseteq \\mathbb{R}$ that is bounded above has a least upper bound.\nHere we explore the converse statement: any set of reals that has a supremum is non-empty and \nhas an upper bound. The second part of the result is trivial, but showing that the\nset is non-empty will ask you to use techniques learned in the first world.\n-/\n\n-- definition is_upper_bound' (S : set \u211d) (x : \u211d) := x \u2208 upper_bounds S \n-- (Definition above deprecated? GT)\n\ndefinition is_lub (S : set \u211d) (x : \u211d) := is_upper_bound S x \u2227 \n\u2200 y : \u211d, is_upper_bound S y \u2192 x \u2264 y\n\ndefinition has_lub (S : set \u211d) := \u2203 x, is_lub S x \n\nlocal attribute [instance] classical.prop_decidable --hide\n\n\n/- Lemma\nAny set of reals that has a supremum is non-empty and bounded above.\n-/\ntheorem nonempty_and_bounded_of_has_LUB (S : set \u211d) (H : has_lub S) : \n  (S \u2260 \u2205) \u2227 (\u2203 x, is_upper_bound S x) :=\nbegin\n", "proof": "  cases H with b Hb,\n  -- b is LUB, Hb is proof it's LUB\n  split,\n  { -- first prove S is not empty, by contradiction as usual with empty sets\n    intro Hempty,\n    have H1 : (b-1) \u2208 upper_bounds S,\n    change \u2200 x \u2208 S, x \u2264 (b-1),\n    by_contradiction hn,\n    push_neg at hn,\n    cases hn with x h1, \n    cases h1 with h11 h12,\n    rw Hempty at h11, \n    exact h11, \n    unfold is_lub at Hb,\n    have HH := Hb.2 (b-1) H1, -- b - 1 is an upper bound\n    linarith,\n  },\n  {\n     existsi b,\n     exact Hb.1,\n  }, \n  done", "proof_hint": "sorry", "textAfter": "\nend \n\nend xena -- hide\n", "height": 22, "editorText": "sorry", "lineOffset": 37, "name": "nonempty_and_bounded_of_has_LUB", "statement": "(S : set \u211d) (H : has_lub S) : \n  (S \u2260 \u2205) \u2227 (\u2203 x, is_upper_bound S x)"}, {"type": "lean", "content": "190", "hidden": true}], "url": ""}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "191", "hidden": false}, {"type": "lean", "content": "192", "hidden": true}, {"type": "text", "content": "193"}, {"type": "text", "content": "194"}, {"type": "lean", "content": "195", "hidden": false}, {"type": "lean", "content": "196", "hidden": true}, {"type": "lemma", "text": "197", "lean": "lemma lub_of_open_set : is_lub reals_lt_59 59 := \n", "sideBar": true, "firstProofLineNumber": 41, "lastProofLineNumber": 54, "textBefore": "import game.sup_inf.level02\nimport data.real.basic\n\nnamespace xena -- hide\n\n/-\n# Chapter 3 : Sup and Inf\n\n## Level 3\n-/\n\n/- \nThis level asks you to prove what the supremum of a given open set is.\n-/\n\ndefinition reals_lt_59 := {x : \u211d | x < 59}\n\n-- begin hide\n-- The next result must be placed in the sidebar axioms.\ntheorem helper_lemma (x y : \u211d) (H : x < y) : x < (x + y) / 2 \u2227 (x + y) / 2 < y :=\nbegin\n  have two_ge_zero : (2 : \u211d) \u2265 0 := by norm_num,\n  split,\n  { apply lt_of_mul_lt_mul_right _ two_ge_zero,\n    rw [mul_two,div_mul_cancel],\n    apply add_lt_add_left H,\n    norm_num},\n  { apply lt_of_mul_lt_mul_right _ two_ge_zero,\n    rw [div_mul_cancel,mul_two],\n    apply add_lt_add_right H,\n    norm_num,\n  },\nend\n-- end hide\n\n/- Lemma\nThe LUB of...\n-/\nlemma lub_of_open_set : is_lub reals_lt_59 59 := \nbegin\n", "proof": "  split,\n  { intros s Hs,\n    exact le_of_lt Hs,\n  },\n  { intros y Hy,\n    apply le_of_not_gt,\n    intro H,\n    let s := (y + 59) / 2,\n    have H1 : y < s := (helper_lemma _ _ H).1,\n    have H2 : s < 59 := (helper_lemma _ _ H).2,\n--    unfold is_upper_bound at Hy,\n    have H1' := Hy s H2,\n    exact not_le_of_lt H1 H1', --of_not_gt\n  }", "proof_hint": "sorry", "textAfter": "\nend \n\nend xena -- hide\n", "height": 14, "editorText": "sorry", "lineOffset": 40, "name": "lub_of_open_set", "statement": "is_lub reals_lt_59 59"}, {"type": "lean", "content": "198", "hidden": true}], "url": ""}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "199", "hidden": false}, {"type": "lean", "content": "200", "hidden": true}, {"type": "text", "content": "201"}, {"type": "text", "content": "202"}, {"type": "lean", "content": "203", "hidden": true}, {"type": "lemma", "text": "204", "lean": "lemma lub_open (y : \u211d) : is_lub {x : \u211d | x < y} y :=\n", "sideBar": true, "firstProofLineNumber": 43, "lastProofLineNumber": 61, "textBefore": "import game.sup_inf.level03\nimport data.real.basic\n\nnamespace xena -- hide\n\n/-\n# Chapter 3 : Sup and Inf\n\n## Level 4 \n-/\n\n/-\nA generalization of the result in the previous level.\n-/\n\n-- begin hide\n-- these three helper results to go in sidebar\nlemma two_real_ne_zero : (2:\u211d) \u2260 0 :=\nbegin\n    intro, linarith,\nend\n\nlemma avg_lt_max {mn mx: \u211d} (H : mn < mx) : (mn+mx) / 2 < mx :=\nbegin\n  apply (mul_lt_mul_right (show (0:\u211d)<2, by norm_num)).1,\n  rw [div_mul_cancel _ (two_real_ne_zero)],\n  simp [H,mul_two],\nend\n\nlemma min_lt_avg {mn mx: \u211d} (H : mn < mx) : mn < (mn+mx) / 2 :=\nbegin\n  apply (mul_lt_mul_right (show (0:\u211d)<2, by norm_num)).1,\n  rw [div_mul_cancel _ (two_real_ne_zero)],\n  simp [H,mul_two],\nend\n-- end hide\n\n/- Lemma\nA more general version of the previous level...\n-/\nlemma lub_open (y : \u211d) : is_lub {x : \u211d | x < y} y :=\nbegin\n", "proof": "split,\n{ intros a ha,\n  exact le_of_lt ha, \n},\n--unfold lower_bounds,\nintro b,\nintro Hb,\nrefine le_of_not_gt _,\nintro Hnb,\nlet c:=(b+y)/2,\n--unfold upper_bounds at Hb,\nhave H2 := Hb c,\nclear Hb,\nhave H : c \u2208 {x : \u211d | x < y},\n{ exact avg_lt_max Hnb,\n},\nhave Hcleb := H2 H,\nhave Hbltc : b < c := min_lt_avg Hnb,\nexact not_lt.2 Hcleb Hbltc,", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena -- hide\n\n\n", "height": 19, "editorText": "sorry", "lineOffset": 42, "name": "lub_open", "statement": "(y : \u211d) : is_lub {x : \u211d | x < y} y"}, {"type": "lean", "content": "205", "hidden": true}], "url": ""}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "206", "hidden": false}, {"type": "lean", "content": "207", "hidden": true}, {"type": "text", "content": "208"}, {"type": "lean", "content": "209", "hidden": true}, {"type": "lean", "content": "210", "hidden": false}, {"type": "lemma", "text": "211", "lean": "lemma sup_sum_sets (A : set \u211d) (B : set \u211d) (h1A : A.nonempty) (h1B : B.nonempty) \n  (h2A : bdd_above A) (h2B : bdd_above B) (a : \u211d) (b : \u211d) : \n  (is_lub A a) \u2227 (is_lub B b) \u2192 is_lub (mem_sum_sets A B) (a + b) :=\n", "sideBar": true, "firstProofLineNumber": 24, "lastProofLineNumber": 68, "textBefore": "import game.sup_inf.level04\n\nnamespace xena -- hide\n\n/-\n# Chapter 3 : Sup and Inf\n\n## Level 5\n\nA classical result: the supremum of an element-wise sum of sets.\n-/\n\n-- see also ds_infSum.lean for only the better-organized version -- hide\ndef mem_sum_sets (A : set \u211d) (B : set \u211d) := { x : \u211d | \u2203 y \u2208 A, \u2203 z \u2208 B, x = y + z}\n\n/- Lemma\nIf $A$ and $B$ are sets of reals, then\n$$ \\textrm{sup} (A + B) = \\textrm{sup} (A) + \\textrm{sup}(B)$$\n-/\nlemma sup_sum_sets (A : set \u211d) (B : set \u211d) (h1A : A.nonempty) (h1B : B.nonempty) \n  (h2A : bdd_above A) (h2B : bdd_above B) (a : \u211d) (b : \u211d) : \n  (is_lub A a) \u2227 (is_lub B b) \u2192 is_lub (mem_sum_sets A B) (a + b) :=\nbegin\n", "proof": "  intro h,\n  cases h with hA hB,\n  split,\n  { -- prove that (a+b) is an upper bound\n    intros x h0,\n    cases h0 with y h1, cases h1 with yA h2,\n    cases h2 with z h3, cases h3 with zB hx,\n    have H12A := hA.left, have H12B := hB.left,\n    have H13A := H12A y yA, have H13B := H12B z zB,\n    linarith,\n  },\n  -- now prove that (a+b) is the least upper bound\n  intros S hS,\n  --change \u2200 xab \u2208 (sum_of_sets A B), xab \u2264 S at hS,\n  have H1 : \u2200 y \u2208 A, \u2200 z \u2208 B, (y + z) \u2208 (mem_sum_sets A B),\n    intros y hy z hz,\n    unfold mem_sum_sets, \n    existsi y, existsi hy, existsi z, existsi hz, refl,\n  have H2 : \u2200 y \u2208 A, \u2200 z \u2208 B, (y + z) \u2264 S, \n    intros y hy z hz,\n    apply hS, exact H1 y hy z hz,\n  have H3 : \u2200 y \u2208 A, \u2200 z \u2208 B, y \u2264 S - z,\n    intros y hy z hz,\n    have H3a := H2 y hy z hz,\n    exact le_sub_right_of_add_le H3a,\n  have h21B := hB.right, have h22B := hB.left,\n  --change \u2200 z \u2208 B, z \u2264 b at h22B,\n  have H4 : \u2200 z \u2208 B, (S - z) \u2208 upper_bounds A, --!\n    intros z hz y hy,\n    exact H3 y hy z hz,\n  have H5 : \u2200 z \u2208 B, a \u2264 (S - z), \n    intros z hz,\n    have H13A := hA.right,\n    change \u2200 u \u2208 upper_bounds A, a \u2264 u at H13A,\n    have H5a := H4 z hz, \n    exact H13A (S-z) H5a,\n  have H6 : \u2200 z \u2208 B, z \u2264 S - a,\n    intros z hz,\n    have H6a := H5 z hz, exact le_sub.1 H6a,\n  --have H7 : (S - a) \u2208 upper_bounds B, exact H6,\n  have H8 : b \u2264 (S-a),\n    have H13B := hB.right,\n    change \u2200 u \u2208 upper_bounds B, b \u2264 u at H13B,\n    exact H13B (S-a) H6,  -- I had H7 instead of H6 here\n  exact add_le_of_le_sub_left H8, done", "proof_hint": "sorry", "textAfter": "\nend\n\n\n-- begin hide\n-- Kevin's term proof for second part\n-- NOTE: I altered this after is_lub changed. I don't *think* it's broken -- GT.\nlemma sup_sum_of_sets' (A : set \u211d) (B : set \u211d) (a : \u211d) (b : \u211d)\n  (hA : is_lub A a) (hB : is_lub B b) :\n  a + b \u2208 lower_bounds (upper_bounds (mem_sum_sets A B)) :=\n    \u03bb S hS, add_le_of_le_sub_left $ hB.2 (S - a) $ \u03bb z hz, le_sub.1 $ hA.2 (S - z) $ \u03bb y hy, \n    le_sub_right_of_add_le $ hS \u27e8y, hy, z, hz, rfl\u27e9\n\n-- Patrick Massot's proof for second part\nlemma sup_sum_of_sets'' (A : set \u211d) (B : set \u211d) (a : \u211d) (b : \u211d)\n  (hA : is_lub A a) (hB : is_lub B b) :\n  a + b \u2208 lower_bounds (upper_bounds (mem_sum_sets A B)) :=\nbegin\n    intros S hS,\n  have H1 : \u2200 x \u2208 A, S - x \u2208 upper_bounds B,\n  { intros x hx y hy,\n    suffices : x + y \u2264 S, by linarith, -- by rwa le_sub_iff_add_le',\n    exact hS \u27e8x, hx, y, hy, rfl\u27e9, },\n  have H2 : S - b \u2208 upper_bounds A,\n  { intros x hx,\n    suffices : b \u2264 S - x, by linarith, -- by rwa le_sub,\n    exact hB.2 (S - x) (H1 x hx) },\n  linarith [hA.2 (S - b) H2],  --exact le_sub_iff_add_le.mp (hA.2 H2),\nend\n\n--- end hide\nend xena -- hide\n", "height": 45, "editorText": "sorry", "lineOffset": 23, "name": "sup_sum_sets", "statement": "(A : set \u211d) (B : set \u211d) (h1A : A.nonempty) (h1B : B.nonempty) \n  (h2A : bdd_above A) (h2B : bdd_above B) (a : \u211d) (b : \u211d) : \n  (is_lub A a) \u2227 (is_lub B b) \u2192 is_lub (mem_sum_sets A B) (a + b)"}, {"type": "lean", "content": "212", "hidden": true}], "url": ""}, {"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "213", "hidden": false}, {"type": "lean", "content": "214", "hidden": true}, {"type": "text", "content": "215"}, {"type": "lean", "content": "216", "hidden": false}, {"type": "lemma", "text": "217", "lean": "lemma inf_sum_of_sets (A : set \u211d) (B : set \u211d) (h1A : A.nonempty) (h1B : B.nonempty) \n  (h2A : bdd_below A) (h2B : bdd_below B) (a : \u211d) (b : \u211d) : \n  (is_glb A a) \u2227 (is_glb B b) \u2192 is_glb (sum_of_sets A B) (a + b) :=\n", "sideBar": true, "firstProofLineNumber": 23, "lastProofLineNumber": 50, "textBefore": "import game.sup_inf.supSumSets\nnamespace xena -- hide\n\n/-\n# Chapter 3 : Sup and Inf\n\n## Level 6\n\nThis level, very similar to the previous, showcases the infimum.\n-/\n\ndef sum_of_sets (A : set \u211d) (B : set \u211d) := { x : \u211d | \u2203 y \u2208 A, \u2203 z \u2208 B, x = y + z}\n\n\n/- Lemma\nIf $A$ and $B$ are sets of reals, then\n$$ \\textrm{inf} (A + B) = \\textrm{inf} (A) + \\textrm{inf}(B)$$\n-/\nlemma inf_sum_of_sets (A : set \u211d) (B : set \u211d) (h1A : A.nonempty) (h1B : B.nonempty) \n  (h2A : bdd_below A) (h2B : bdd_below B) (a : \u211d) (b : \u211d) : \n  (is_glb A a) \u2227 (is_glb B b) \u2192 is_glb (sum_of_sets A B) (a + b) :=\nbegin\n", "proof": "  intro h,\n  cases h with hA hB,\n  split,\n  -- prove that (a+b) is a lower bound\n  intros x h0,\n  cases h0 with y h1,\n  cases h1 with yA h2,\n  cases h2 with z h3,\n  cases h3 with zB hx,\n  --have H11A := hA.right, have H11B := hB.right,\n  have H12A := hA.left, have H12B := hB.left,\n  have H13A := H12A yA, have H13B := H12B zB,\n  linarith,\n  -- now prove (a+b) is the greatest lower bound\n  intros L hL,  -- L is another lower bound of (A+B)\n  have H1 : \u2200 x \u2208 A, (L - x) \u2208 lower_bounds B,\n  { \n    intros x hx y hy, \n    suffices : L \u2264 x + y, by linarith,\n    exact hL \u27e8x, hx, y, hy, rfl\u27e9,\n  },\n  have H2 : L - b \u2208 lower_bounds A,\n  { \n    intros x hx, \n    suffices : L - x \u2264 b, by linarith,\n    exact hB.2 (H1 x hx),\n  },\n  linarith [hA.2 H2], done", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena -- hide\n", "height": 28, "editorText": "sorry", "lineOffset": 22, "name": "inf_sum_of_sets", "statement": "(A : set \u211d) (B : set \u211d) (h1A : A.nonempty) (h1B : B.nonempty) \n  (h2A : bdd_below A) (h2B : bdd_below B) (a : \u211d) (b : \u211d) : \n  (is_glb A a) \u2227 (is_glb B b) \u2192 is_glb (sum_of_sets A B) (a + b)"}, {"type": "lean", "content": "218", "hidden": true}], "url": ""}, {"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "219", "hidden": false}, {"type": "lean", "content": "220", "hidden": true}, {"type": "text", "content": "221"}, {"type": "lean", "content": "222", "hidden": false}, {"type": "lemma", "text": "223", "lean": "lemma inf_sum_set_const (A : set \u211d) (h1A : A.nonempty)\n  (h2A : bdd_below A) (a : \u211d) (c : \u211d): \n  (is_glb A a) \u2192 is_glb (sum_set_const A c) (c + a) :=\n", "sideBar": true, "firstProofLineNumber": 23, "lastProofLineNumber": 41, "textBefore": "import game.sup_inf.infSumSets\nnamespace xena -- hide\n\n/-\n# Chapter 3 : Sup and Inf\n\n## Level 7\n\nAnother level that showcases the infimum.\n-/\n\ndef sum_set_const (A : set \u211d) (c : \u211d) := { x : \u211d | \u2203 y \u2208 A, x = y + c}\n\n\n/- Lemma\nIf $A$ is a set of reals, then\n$$ \\textrm{inf} (c + A) = c + \\textrm{inf} (A)$$\n-/\nlemma inf_sum_set_const (A : set \u211d) (h1A : A.nonempty)\n  (h2A : bdd_below A) (a : \u211d) (c : \u211d): \n  (is_glb A a) \u2192 is_glb (sum_set_const A c) (c + a) :=\nbegin\n", "proof": "  intro h,\n  cases h with hA hB,\n  split,\n  -- prove that (c+a) is a lower bound\n  intros x h0,\n  cases h0 with y h1,\n  cases h1 with yA h2,\n  { have h2 := hA yA, linarith, },\n  -- prove that (c+a) is the GLB\n  intros L hL,\n  have h3 : L - c \u2208 lower_bounds A,\n    intros y hy,\n    set x := y + c with hx,\n    have h31 : x \u2208 sum_set_const A c,\n      unfold sum_set_const, \n      split, swap, use y, split, exact hy, exact hx,\n    have h32 := hL h31, rw hx at h32, linarith,\n  have h4 := hB h3, linarith,\n  done", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena -- hide\n", "height": 19, "editorText": "sorry", "lineOffset": 22, "name": "inf_sum_set_const", "statement": "(A : set \u211d) (h1A : A.nonempty)\n  (h2A : bdd_below A) (a : \u211d) (c : \u211d): \n  (is_glb A a) \u2192 is_glb (sum_set_const A c) (c + a)"}, {"type": "lean", "content": "224", "hidden": true}], "url": ""}, {"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "225", "hidden": false}, {"type": "lean", "content": "226", "hidden": true}, {"type": "text", "content": "227"}, {"type": "lean", "content": "228", "hidden": false}, {"type": "lemma", "text": "229", "lean": "lemma sup_const_times_set (c : \u211d) (hc: 0 < c) (A : set \u211d) (h1A : A.nonempty)\n  (h2A : bdd_above A) (a : \u211d) : \n  (is_lub A a) \u2192 is_lub (const_times_set c A) (c * a) :=\n", "sideBar": true, "firstProofLineNumber": 24, "lastProofLineNumber": 46, "textBefore": "import game.sup_inf.infSumConst\n\nnamespace xena -- hide\n\n/-\n# Chapter 3 : Sup and Inf\n\n## Level 8\n\nAgain a classical result.\n-/\n\n-- supremum of constant \u00d7 set\ndef const_times_set (c: \u211d) (A : set \u211d) := { x : \u211d | \u2203 y \u2208 A, x = c * y }\n\n/- Lemma\nIf $A$ is a set of reals and $c > 0$, then\n$$ \\textrm{sup} (cA) = c \\cdot \\textrm{sup} (A)$$\n-/\nlemma sup_const_times_set (c : \u211d) (hc: 0 < c) (A : set \u211d) (h1A : A.nonempty)\n  (h2A : bdd_above A) (a : \u211d) : \n  (is_lub A a) \u2192 is_lub (const_times_set c A) (c * a) :=\nbegin\n", "proof": "  intro h,\n  cases h with hA1 hA2,\n  split,\n  { -- prove that (c*a) is an upper bound\n    intros x h0,\n    cases h0 with y h1, cases h1 with yA h2,\n    have H13A := hA1 y yA, rw h2, \n    exact (mul_le_mul_left hc).mpr H13A,\n  },\n  -- now prove that (c*a) is the least upper bound\n  intros S hS,\n  set y1 := S / c with hys,\n  have H : y1 \u2208 upper_bounds A,\n    intros x hx,\n    have G := hA1 x hx, \n    set xc := c * x with hxc,\n    have G1 : xc \u2208 const_times_set c A, \n        use x, existsi hx, exact hxc,\n    have G2 := hS xc G1, rw hxc at G2,  \n    rw hys, exact (le_div_iff' hc).mpr G2,\n  have F := hA2 y1 H, rw hys at F, \n  have E := (mul_le_mul_left hc).mpr F,\n  exact (le_div_iff' hc).mp F, done", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena -- hide\n", "height": 23, "editorText": "sorry", "lineOffset": 23, "name": "sup_const_times_set", "statement": "(c : \u211d) (hc: 0 < c) (A : set \u211d) (h1A : A.nonempty)\n  (h2A : bdd_above A) (a : \u211d) : \n  (is_lub A a) \u2192 is_lub (const_times_set c A) (c * a)"}, {"type": "lean", "content": "230", "hidden": true}], "url": ""}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "231", "hidden": false}, {"type": "lean", "content": "232", "hidden": true}, {"type": "text", "content": "233"}, {"type": "lean", "content": "234", "hidden": false}, {"type": "lean", "content": "235", "hidden": true}, {"type": "text", "content": "236"}, {"type": "lemma", "text": "237", "lean": "lemma mem_prod_sets_lub_proof : \n  is_lub (mem_prod_sets (set.Icc (-2:\u211d) (-1:\u211d)) (set.Icc (0:\u211d) (3:\u211d)) ) 0 := \n", "sideBar": true, "firstProofLineNumber": 31, "lastProofLineNumber": 47, "textBefore": "import ..sup_inf.supProdConst\nimport ..sets.sets_level09\n\nnamespace xena -- hide\n\n/-\n# Chapter 3 : Sup and Inf\n\n## Level 9\n\nAn intermediary result to be used in the next level.\n-/\n\n-- main result in lemma sup_mem_prod_of_sets\n-- begin hide\n--def mem_prod_sets (A : set \u211d) (B : set \u211d) := { x : \u211d | \u2203 y \u2208 A, \u2203 z \u2208 B, x = y * z}\n-- end hide\n\n\n/-\nProve that a given real number is the supremum of a particular set.\n-/\n\n/- Lemma\nGiven two sets of reals $A$ and $B$, show that given real number is the LUB\nof their elementwise product `mem_prod_sets`.\n-/\nlemma mem_prod_sets_lub_proof : \n  is_lub (mem_prod_sets (set.Icc (-2:\u211d) (-1:\u211d)) (set.Icc (0:\u211d) (3:\u211d)) ) 0 := \nbegin\n", "proof": "  split,\n  intros x h1,\n  cases h1 with a hh, cases hh with ha h2,\n  cases h2 with b h3, cases h3 with hb hx,\n  have H : a \u2264 0, \n    cases ha with hg hl,\n    linarith,\n  have G : b \u2265 0, \n    cases hb with hg hl, exact hg,\n  rw hx, exact mul_nonpos_of_nonpos_of_nonneg H G,\n  intros x hx,\n  by_contradiction hnx,\n  push_neg at hnx,\n  --TODO: kmb doesn't know what zero_in_prod is, and it's not compiling\n  have E := zero_in_prod,\n  have D := hx 0 E, linarith, done\n  --sorry", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena -- hide\n\n", "height": 17, "editorText": "sorry", "lineOffset": 30, "name": "mem_prod_sets_lub_proof", "statement": "is_lub (mem_prod_sets (set.Icc (-2:\u211d) (-1:\u211d)) (set.Icc (0:\u211d) (3:\u211d)) ) 0"}, {"type": "lean", "content": "238", "hidden": true}], "url": ""}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "239", "hidden": false}, {"type": "lean", "content": "240", "hidden": true}, {"type": "text", "content": "241"}, {"type": "lean", "content": "242", "hidden": false}, {"type": "lean", "content": "243", "hidden": true}, {"type": "lean", "content": "244", "hidden": false}, {"type": "text", "content": "245"}, {"type": "lemma", "text": "246", "lean": "lemma sup_mem_prod_of_sets : \u00ac ( \u2200 (A B : set \u211d) (a b : \u211d),\n  A.nonempty \u2227 B.nonempty \u2192 bdd_below A \u2227 bdd_below B \u2192\n  is_lub A a \u2227 is_lub B b \u2192 \n  is_lub (mem_prod_sets A B) (a * b) ) :=\n", "sideBar": true, "firstProofLineNumber": 34, "lastProofLineNumber": 65, "textBefore": "import .lub_prodSets\n\nnamespace xena -- hide\n\n/-\n# Chapter 3 : Sup and Inf\n\n## Level 10\n-/\n\n\n-- main result in lemma sup_mem_prod_of_sets\n-- hide\n--def mem_prod_sets (A : set \u211d) (B : set \u211d) := { x : \u211d | \u2203 y \u2208 A, \u2203 z \u2208 B, x = y * z}\n\n\n/-\nIntermediary result `zero_in_prod` proved in sets_level08.\n\nIntermediary result `mem_prod_sets_lub_proof` in previous level.\n-/\n\n\n/- Lemma\nFor two non-empty sets of reals $A$ and $B$, it is not in general true that\n$$ \\textrm{sup} (A \\cdot B) = \\textrm{sup} (A) \\cdot \\textrm{sup}(B)$$\nwhere $A \\cdot B$ is defined pointwise as above.\n-/\nlemma sup_mem_prod_of_sets : \u00ac ( \u2200 (A B : set \u211d) (a b : \u211d),\n  A.nonempty \u2227 B.nonempty \u2192 bdd_below A \u2227 bdd_below B \u2192\n  is_lub A a \u2227 is_lub B b \u2192 \n  is_lub (mem_prod_sets A B) (a * b) ) :=\nbegin\n", "proof": "  intro H,\n  -- do an example with A = [-2,-1], B = [0,3]\n  set A1 : set \u211d := set.Icc (-2:\u211d) (-1:\u211d) with hA,\n  set B1 : set \u211d := set.Icc (0:\u211d) (3:\u211d) with hB,\n  set a : \u211d := (-1:\u211d) with ha,\n  set b : \u211d := (3 : \u211d) with hb,\n  have G := H A1 B1,\n  have h1A : A1.nonempty, simp, norm_num,\n  have h1B : B1.nonempty, simp, norm_num,\n  have F := G a b (and.intro h1A h1B),\n  have h11 : ((-2:\u211d) \u2264 -1), norm_num,\n  have h21 : (0:\u211d) \u2264 (3:\u211d), norm_num,\n  have h2A : bdd_below A1, \n    -- use the definition in bounds.lean\n    have h12 := is_glb_Icc h11,\n    cases h12 with hh hhh,\n    existsi (-2:\u211d), exact hh,\n  have h2B : bdd_below B1, \n    have h22 := is_glb_Icc h21,\n    cases h22 with hh hhh,\n    existsi (0:\u211d), exact hh,\n  have E := F (and.intro h2A h2B),\n  have h1 : is_lub A1 a, \n    exact is_lub_Icc h11,\n  have h2 : is_lub B1 b, \n    exact is_lub_Icc h21,\n  have D := E (and.intro h1 h2),\n  rw ha at h1, rw hb at h2, rw ha at D, rw hb at D,\n  have E : is_lub (mem_prod_sets A1 B1) 0, \n    exact mem_prod_sets_lub_proof,\n  have E1 := is_lub.unique D E,\n  linarith, done", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena -- hide\n", "height": 32, "editorText": "sorry", "lineOffset": 33, "name": "sup_mem_prod_of_sets", "statement": "\u00ac ( \u2200 (A B : set \u211d) (a b : \u211d),\n  A.nonempty \u2227 B.nonempty \u2192 bdd_below A \u2227 bdd_below B \u2192\n  is_lub A a \u2227 is_lub B b \u2192 \n  is_lub (mem_prod_sets A B) (a * b) )"}, {"type": "lean", "content": "247", "hidden": true}], "url": ""}, {"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "248", "hidden": false}, {"type": "lean", "content": "249", "hidden": true}, {"type": "text", "content": "250"}, {"type": "lean", "content": "251", "hidden": false}, {"type": "lemma", "text": "252", "lean": "lemma not_lub_rationals : \u2200 b : \u211d, \u00ac (is_lub (embedded_rationals) b) :=\n", "sideBar": true, "firstProofLineNumber": 18, "lastProofLineNumber": 25, "textBefore": "import game.sup_inf.supProdSets\n\nnamespace xena -- hide\n\n/-\n# Chapter 3 : Sup and Inf\n\n## Level 11\n-/\n\ndef embedded_rationals : set \u211d := {x : \u211d | \u2203 y : \u211a, x = \u2191y}\n\n/- Lemma\nThe set of rational numbers does not have a supremum\n-/\nlemma not_lub_rationals : \u2200 b : \u211d, \u00ac (is_lub (embedded_rationals) b) :=\nbegin\n", "proof": "intros b Hlub,\nhave Hbub : b \u2208 upper_bounds embedded_rationals := Hlub.left,\nhave H : b < (b+1) := calc b = b+0 : (add_zero _).symm\n                         ... < b+1 : add_lt_add_left zero_lt_one _,\ncases (exists_rat_btwn H) with q Hq,\nhave Hqin : \u2191q \u2208 embedded_rationals := \u27e8q,rfl\u27e9,\nhave Hwrong2 := Hbub Hqin,\nexact not_lt.2 Hwrong2 (Hq.left),", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena -- hide\n", "height": 8, "editorText": "sorry", "lineOffset": 17, "name": "not_lub_rationals", "statement": "\u2200 b : \u211d, \u00ac (is_lub (embedded_rationals) b)"}, {"type": "lean", "content": "253", "hidden": true}], "url": ""}, {"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "254", "hidden": false}, {"type": "lean", "content": "255", "hidden": true}, {"type": "text", "content": "256"}, {"type": "lean", "content": "257", "hidden": false}, {"type": "lemma", "text": "258", "lean": "lemma nats_unbounded_iff : \n    unboundedAbove {x : \u211d | \u2203 n : \u2115, x = n \u2227 n > 0} \u2194 archimPrinciple :=\n", "sideBar": true, "firstProofLineNumber": 22, "lastProofLineNumber": 50, "textBefore": "import game.sup_inf.lub_rationals\nimport data.real.basic\n\nnamespace xena -- hide\n\n/-\n# Chapter 3 : Sup and Inf\n\n## Level 12\n-/\n\ndef unboundedAbove (A : set \u211d) := \u2200 x : \u211d, x > 0 \u2192 \u2203 a \u2208 A, x < a\n-- Might want to make this into an axiom to be placed on the left\ndef archimPrinciple := \u2200 x : \u211d, x > 0 \u2192  \u2203 n : \u2115, n > 0 \u2227 (1/n : \u211d) < x \n\n/- Lemma\nThe Archimedean principle is equivalent to the set of natural numbers being unbounded above.\n-/\nlemma nats_unbounded_iff : \n    unboundedAbove {x : \u211d | \u2203 n : \u2115, x = n \u2227 n > 0} \u2194 archimPrinciple :=\nbegin\n", "proof": "    split,\n    -- left-right implication\n    intros unb x hx,\n    set A := {x : \u211d | \u2203 n : \u2115, x = n \u2227 x > 0} with hA,\n    have h1x : (1/x) > 0, from one_div_pos_of_pos hx,\n    have h1 := unb (1/x) h1x,\n    -- rcases h1 with \u27e8nx, \u27e8n, rfl\u27e9, h2\u27e9,\n    cases h1 with nx hnx,\n    cases hnx with h1 h2,\n    cases h1 with xn h12,\n    existsi xn, rw h12.left at h2, \n    have h0 : 0 < (1:\u211d), norm_num,\n    have h3 := div_lt_div_of_pos_of_lt_of_pos h1x h2 h0,\n    split, exact h12.right,\n    simp at h3, simp, \n    exact h3,\n    -- right-left implication\n    intros arc x hx,\n    have h1x : (1/x) > 0, from one_div_pos_of_pos hx,\n    have h1 := arc (1/x) h1x,\n    cases h1 with n hn,\n    use n, split, \n    existsi n, split, refl, exact hn.left,\n    set xn : \u211d := \u2191n with hxn, \n    have h2n : 0 < xn, \n        rw hxn, \n        have hn0 : 0 < n, from hn.left, simp, assumption,\n    exact lt_of_one_div_lt_one_div h2n hn.right,\n    done", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena -- hide\n", "height": 29, "editorText": "sorry", "lineOffset": 21, "name": "nats_unbounded_iff", "statement": "unboundedAbove {x : \u211d | \u2203 n : \u2115, x = n \u2227 n > 0} \u2194 archimPrinciple"}, {"type": "lean", "content": "259", "hidden": true}], "url": ""}, {"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "260", "hidden": false}, {"type": "lean", "content": "261", "hidden": true}, {"type": "text", "content": "262"}, {"type": "lean", "content": "263", "hidden": false}, {"type": "lemma", "text": "264", "lean": "lemma not_complete_rationals : \n    \u00ac complete embedded_rationals :=\n", "sideBar": true, "firstProofLineNumber": 29, "lastProofLineNumber": 80, "textBefore": "import game.sup_inf.unbdd_iff\nimport data.real.basic\n\nnamespace xena -- hide\n\n/-\n# Chapter 3 : Sup and Inf\n\n## Level 13\n\nThis proof will be easy now.\nActually this needs quite some work due to coercions etc.\nMay need to change definitions.\n-/\n\ndef bdd (X : set \u211d) := bdd_above X \u2227 bdd_below X\ndef complete (X : set \u211d) := \n    \u2200 Y : set \u211d, Y.nonempty \u2227 Y \u2286 X \u2227 bdd Y \u2192 \u2203 s \u2208 X, is_lub Y s \u2227 \u2203 i \u2208 X, is_glb Y i\n\n\n/- Lemma\nThe rational numbers are not complete.\n\nNeed to complete the proof.\n-/\nlemma not_complete_rationals : \n    \u00ac complete embedded_rationals :=\nbegin\n", "proof": "   -- the plan here is to use the set { x : \u211a | x ^2 < 2}\n   -- this is bounded, and the sup S will satisfy neither\n   -- S ^ 2 < 2 nor S ^ 2 > 2 (due to density of rationals)\n   -- so S ^ 2 = 2, but there's not such S \u2208 \u211a\n   -- (as per sets/sqrt2NotRational.lean)\n   intro H,\n   set Y : set \u211d := { y | \u2203 x : \u211a, y = \u2191x \u2227 0 \u2264 x \u2227 x ^ 2 < (2:\u211a) } with hY,\n   -- Y is not empty\n   have h1Y : Y.nonempty, \n   {  --change \u2203 y : \u211d, y \u2208 Y,\n      use (0: \u211d), use (0 : \u211a), split, norm_cast, split,\n      linarith, rw [pow_two, zero_mul], linarith,\n   },\n   have h2Y : Y \u2286 embedded_rationals, \n   {  intros y hy, --unfold embedded_rationals,\n      cases hy with x hy1, cases hy1 with hyx hy2, --simp,\n      use x, exact hyx,\n    },\n   have h3Y : bdd Y, \n   { split, \n     -- bdd_above\n     use (2:\u211d), intros y hy, \n     cases hy with x hx1, cases hx1 with hxy hx2, cases hx2 with hx3 hx4,\n     have h1 : (2 : \u211d) < 4, linarith, \n     have h2 : (x ^ 2 : \u211d) < 4, norm_cast, linarith,\n     have h3 : 0 \u2264 (x ^ 2 : \u211d), exact pow_two_nonneg x,\n     have h4 : 0 \u2264 (4:\u211d), linarith, \n     have h5 := (real.sqrt_lt h3 h4).mpr h2,\n     have h51 : 0 \u2264 (x : \u211d), norm_cast, exact hx3,\n     have h6 := real.sqrt_sqr h51, rw h6 at h5, rw \u2190 hxy at h5,\n     have h7 : (4 : \u211d) = 2 ^ 2, norm_num, rw h7 at h5,\n     have h71 : 0 \u2264 (2 : \u211d), linarith,\n     have h8 := real.sqrt_sqr h71, rw h8 at h5, linarith,\n     -- bdd_below\n     use (0:\u211d), intros y hy,\n     cases hy with x hx1, cases hx1 with hxy hx2, cases hx2 with hx3 hx4,\n     rw hxy, norm_cast, exact hx3,\n   },\n   have G := H Y (and.intro h1Y (and.intro h2Y h3Y)), \n   cases G with S hsi, cases hsi with I hsi, cases hsi with hS hI,\n   cases lt_trichotomy (S ^ 2) 2 with hSn hS2,\n   {   -- case S ^ 2 < 2 can be sorted out: use Archimedean property / density\n       sorry, \n    },\n   cases hS2 with hS hSp, swap,\n   { -- case 2 < S^2 can also be sorted out using density of rationals\n       sorry,\n   },\n   { -- the interesting case S^2 = 2, maybe some trouble because of coercions?\n        sorry,\n   },\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena -- hide\n", "height": 52, "editorText": "sorry", "lineOffset": 28, "name": "not_complete_rationals", "statement": "\u00ac complete embedded_rationals"}, {"type": "lean", "content": "265", "hidden": true}], "url": ""}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "266", "hidden": false}, {"type": "lean", "content": "267", "hidden": true}, {"type": "text", "content": "268"}, {"type": "text", "content": "269"}, {"type": "lean", "content": "270", "hidden": true}, {"type": "lean", "content": "271", "hidden": false}, {"type": "text", "content": "272"}, {"type": "lean", "content": "273", "hidden": false}, {"type": "lemma", "text": "274", "lean": "theorem glb_property_reals (S: set \u211d) : \n(S.nonempty \u2227 is_bdd_below S) \u2192 has_glb S :=\n", "sideBar": true, "firstProofLineNumber": 47, "lastProofLineNumber": 91, "textBefore": "import game.sup_inf.rat_complete\n\nnamespace xena --hide \n\n/-\n# Chapter 3 : Sup and Inf\n\n## Level 14\n-/\n\n\n/- \nThe Least Upper Bound property implies\nGreatest Lower bound Property\n-/\n\n-- begin hide\n--NOTE: We have a form of the completeness axiom at Sup/Inf World\n--level 13.\n--Here I'll assume LUB property as an axiom, and prove it implies \n--GLB property. But perhaps `axiom` should be avoided. -- GT\n-- end hide\n\ndef is_bdd_above (S : set \u211d) := \u2203 x : \u211d, is_upper_bound S x    \n\ndef is_lower_bound (S : set \u211d) (x : \u211d) := \u2200 s \u2208 S, x \u2264 s\ndef is_bdd_below (S : set \u211d) := \u2203 x : \u211d, is_lower_bound S x\ndef is_glb (S : set \u211d) (x : \u211d) := is_lower_bound S x \u2227 \n\u2200 y : \u211d, is_lower_bound S y \u2192 y \u2264 x\ndef has_glb (S : set \u211d) := \u2203 x : \u211d, is_glb S x\n\n/-\nCompleteness Axiom\n-/\n\naxiom lub_property_reals (S : set \u211d) : \n(S.nonempty \u2227 is_bdd_above S) \u2192 (has_lub S)\n\n/- Lemma\nLUB property implies GLB property\n-/\n\ntheorem glb_property_reals (S: set \u211d) : \n(S.nonempty \u2227 is_bdd_below S) \u2192 has_glb S :=\n\nbegin\n", "proof": "intro hyp,\n\n--define set L of lower bounds of S\nlet L := { x : \u211d | is_lower_bound S x},  \n\n--anything in S is an upper bound of L\nhave fact1: \u2200 x \u2208 S, is_upper_bound L x,\nintros x hypx b hypb,\nexact hypb x hypx,            -- `suggest` provided this line\n\n--hyp.left is the claim that S is nonempty. use this to show\n--that L is bounded above\ncases hyp.left with y hypy, \nhave fact2: is_bdd_above L, use y, exact fact1 y hypy,\n\n-- can now show that L has supremum `a`. Note direct use of hyp.right\n-- (S is bounded below) as proof that L is nonempty\nhave fact3:= lub_property_reals L (and.intro hyp.right fact2),\ncases fact3 with a hypa,\n\n-- we now show that a is the infimum of S\n\nuse a,\nsplit,\n    -- first prove that a is a lower bound for S,\n    {\n    assume z hypz,\n    -- given z \u2208 S, we prove by contradiction that a \u2264 z,\n    by_contradiction claim,\n    push_neg at claim,\n    unfold is_lub at hypa,\n    -- hypa.right says that for any upper bound y of L, a \u2264 y\n    let for_contra := hypa.right z (fact1 z hypz), \n    -- linarith solves our goal - claim and for_contra are contradictory.\n    linarith,\n    },\n\n    -- now prove that for any lower bound x of S, x \u2264 a \n    {\n    intros x hypx,\n    have fact: x \u2208 L, exact hypx,\n    -- hypa.left says that a is an upper bound of L\n    exact hypa.left x hypx,\n    }\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\nend xena -- hide\n", "height": 45, "editorText": "sorry", "lineOffset": 46, "name": "glb_property_reals", "statement": "(S: set \u211d) : \n(S.nonempty \u2227 is_bdd_below S) \u2192 has_glb S"}, {"type": "lean", "content": "275", "hidden": true}], "url": ""}], "parents": [1]}, {"name": "276", "levels": [{"name": "", "problemIndex": 10, "objects": [{"type": "lean", "content": "277", "hidden": false}, {"type": "lean", "content": "278", "hidden": true}, {"type": "lean", "content": "279", "hidden": true}, {"type": "lean", "content": "280", "hidden": false}, {"type": "lean", "content": "281", "hidden": true}, {"type": "lean", "content": "282", "hidden": false}, {"type": "text", "content": "283"}, {"type": "text", "content": "284"}, {"type": "lean", "content": "285", "hidden": false}, {"type": "text", "content": "286"}, {"type": "lemma", "text": "287", "lean": "lemma limit.unique (a : \u2115 \u2192 \u211d) (l m : \u211d) (hl : is_limit a l) (hm : is_limit a m) : l = m :=\n", "sideBar": true, "firstProofLineNumber": 64, "lastProofLineNumber": 80, "textBefore": "import game.sets.L01defs\n\n--NOTE: the recursive import from previous world breaks run_cmd add_interactive below??\n--I think the problem comes from sup_inf.rat_complete\n--So I will import sup_inf in the next level\n\nimport data.real.basic\nimport tactic.linarith\n\nnamespace xena -- hide\nnotation `|` x `|` := abs x -- hide\n\nlemma zero_of_abs_lt_all (x : \u211d) (h : \u2200 \u03b5 > 0, |x| < \u03b5) : x = 0 :=\neq_zero_of_abs_eq_zero $ eq_of_le_of_forall_le_of_dense (abs_nonneg x) $ \u03bb \u03b5 \u03b5_pos, le_of_lt (h \u03b5 \u03b5_pos)\n\n-- begin hide\n-- The next few things should be hidden\n@[user_attribute]\nmeta def ineq_rules : user_attribute :=\n{ name := `ineq_rules,\n  descr := \"lemmas usable to prove inequalities\" }\n\nattribute [ineq_rules] add_lt_add le_max_left le_max_right\n\nmeta def inequality := `[linarith <|> apply_rules ineq_rules]\nrun_cmd add_interactive [`inequality]\n-- end of scary things\n-- end hide\n\n\n-- World name : Sequences and limits\n\n/-\n# Chapter 3 : Sequences and limits\n\n# Level 1 : Introduction to sequences.\n\nLean's natural numbers start at zero, so it is convenient to let our sequences start from the zeroth term.\nIn other words, a sequence of reals will be $a_0, a_1, a_2, \\ldots$. \n-/\n\n/-\nLet's just step back for a minute and think about what a sequence really *is*. \nIf $n$ is a natural number then $a_n$ is a real number, \nso $n\\mapsto a_n$ is actually a function from natural numbers to real numbers. \nIf we just call this function $a$ then the $n$th term in the sequence\nwill be called `a(n)` or `a n` in Lean, rather than $a_n$, but this is OK.\n\nThe key definition we want is the concept of a limit of a sequence.\n-/\n\ndefinition is_limit (a : \u2115 \u2192 \u211d) (\u03b1 : \u211d) := \n  \u2200 \u03b5 : \u211d, 0 < \u03b5 \u2192 \u2203 N : \u2115, \u2200 n : \u2115, N \u2264 n \u2192 |a n - \u03b1| < \u03b5\n\n/-\nLet's now prove the basic fact that a sequence has at most one limit. \n-/\n\n/- Lemma\nIf $a_n \\to \\ell$ and $a_n \\to m$ then $\\ell = m$. \n-/\nlemma limit.unique (a : \u2115 \u2192 \u211d) (l m : \u211d) (hl : is_limit a l) (hm : is_limit a m) : l = m :=\nbegin\n", "proof": "  wlog h : l \u2264 m,\n  rw le_iff_lt_or_eq at h,\n  cases h,\n    exfalso,\n    generalize h : (m - l) / 2 = \u03b5,\n    have h\u03b5 : 0 < \u03b5,\n      {inequality},\n    cases (hl \u03b5 h\u03b5) with L hL,\n    cases (hm \u03b5 h\u03b5) with M hM,\n    have hL' := hL (max L M) (le_max_left _ _),\n    have hM' := hM (max L M) (le_max_right _ _),\n    rw abs_lt at hL',\n    rw abs_lt at hM',\n    cases hL', cases hM',\n    linarith,\n  assumption,\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena -- hide\n", "height": 17, "editorText": "sorry", "lineOffset": 63, "name": "limit.unique", "statement": "(a : \u2115 \u2192 \u211d) (l m : \u211d) (hl : is_limit a l) (hm : is_limit a m) : l = m"}, {"type": "lean", "content": "288", "hidden": true}], "url": ""}, {"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "289", "hidden": false}, {"type": "lean", "content": "290", "hidden": true}, {"type": "lean", "content": "291", "hidden": true}, {"type": "text", "content": "292"}, {"type": "lemma", "text": "293", "lean": "lemma lim_add (a : \u2115 \u2192 \u211d) (b : \u2115 \u2192 \u211d) (\u03b1 \u03b2 : \u211d) \n    (ha : is_limit a \u03b1) (hb : is_limit b \u03b2) : \n    is_limit ( \u03bb n, (a n) + (b n) ) (\u03b1 + \u03b2) :=\n", "sideBar": true, "firstProofLineNumber": 21, "lastProofLineNumber": 44, "textBefore": "import game.limits.L01defs\nimport game.sup_inf.GLBprop_if_LUBprop\n\n\nnamespace xena -- hide\n\nnotation `|` x `|` := abs x -- hide\n\n/-\nAnother basic result for working with sequences.\n-/\n\n/- Lemma\nIf $\\lim_{n \\to \\infty} a_n = \\alpha$ and $\\lim_{n \\to \\infty} b_n = \\beta$, then\n $\\lim_{n \\to \\infty} (a_n + b_n) = \\alpha + \\beta$\n-/\nlemma lim_add (a : \u2115 \u2192 \u211d) (b : \u2115 \u2192 \u211d) (\u03b1 \u03b2 : \u211d) \n    (ha : is_limit a \u03b1) (hb : is_limit b \u03b2) : \n    is_limit ( \u03bb n, (a n) + (b n) ) (\u03b1 + \u03b2) :=\nbegin\n", "proof": "   intros \u03b5 h\u03b5,\n   set e := \u03b5 / 2 with hedef,\n   have he : 0 < e, linarith,\n   have Ha := ha e he,\n   have Hb := hb e he,\n   cases Ha with na hna,\n   cases Hb with nb hnb,\n   set m := max na nb with hm,\n   have hm1 : m \u2265 na, norm_num, left, linarith,\n   have hm2 : m \u2265 nb, norm_num, right, linarith,\n   use m,\n   intros n hn,\n   have hn1 : n \u2265 na, linarith,\n   have hn2 : n \u2265 nb, linarith,\n   have H1 := hna n hn1,\n   have H2 := hnb n hn2,\n   have H := abs_add (a n - \u03b1) (b n - \u03b2),\n   simp, \n   have G : a n - \u03b1 + (b n - \u03b2) = a n + b n - (\u03b1 + \u03b2), linarith,\n   rw G at H,\n   have F : |a n - \u03b1| + |b n - \u03b2| < 2 * e, linarith,\n   have E : |a n + b n - (\u03b1 + \u03b2)| < 2 * e, linarith,\n   have D : 2 * e = \u03b5, linarith,\n   rw D at E, exact E, done", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena -- hide\n\n", "height": 24, "editorText": "sorry", "lineOffset": 20, "name": "lim_add", "statement": "(a : \u2115 \u2192 \u211d) (b : \u2115 \u2192 \u211d) (\u03b1 \u03b2 : \u211d) \n    (ha : is_limit a \u03b1) (hb : is_limit b \u03b2) : \n    is_limit ( \u03bb n, (a n) + (b n) ) (\u03b1 + \u03b2)"}, {"type": "lean", "content": "294", "hidden": true}], "url": ""}, {"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "295", "hidden": false}, {"type": "lean", "content": "296", "hidden": true}, {"type": "lean", "content": "297", "hidden": true}, {"type": "text", "content": "298"}, {"type": "lemma", "text": "299", "lean": "lemma lim_times_const (a : \u2115 \u2192 \u211d) (\u03b1 c : \u211d) (hL : is_limit a \u03b1) : \n    is_limit (\u03bb n, c * (a n)) (c*\u03b1) :=\n", "sideBar": true, "firstProofLineNumber": 19, "lastProofLineNumber": 65, "textBefore": "import game.limits.L01defs\nimport game.limits.seq_lim_add\n\nnamespace xena -- hide\n\nnotation `|` x `|` := abs x -- hide\n\n/-\nA basic result for working with sequences.\n-/\n\n/- Lemma\nIf $\\lim_{n \\to \\infty} a_n = \\alpha$ and $c \\in \\mathbb{R}$, then\n $\\lim_{n \\to \\infty} (c \\cdot a_n) = c \\cdot \\alpha$\n-/\nlemma lim_times_const (a : \u2115 \u2192 \u211d) (\u03b1 c : \u211d) (hL : is_limit a \u03b1) : \n    is_limit (\u03bb n, c * (a n)) (c*\u03b1) :=\nbegin\n", "proof": "  rcases lt_trichotomy c 0 with hc | hc | hc,\n  {\n    intros \u03b5 h\u03b5,\n    set e := \u03b5 / |c| with he,\n    have cnz : c \u2260 0, linarith,\n    have habsc := abs_pos_iff.mpr cnz,\n    have he_pos := div_pos h\u03b5 habsc,\n    cases hL e he_pos with M hM,\n    use M, intros n hn, rw he at hM, simp,\n    have H := hM n hn,\n    have G := (lt_div_iff' habsc).mp H,\n    have F := abs_mul c,\n    set b := a n - \u03b1 with hb,\n    have E := F b,\n    rw hb at E,\n    have D := mul_sub c (a n) \u03b1,\n    rw D at E, \n    rw \u2190 hb at E,\n    linarith,\n  },\n  {\n    intros \u03b5 h\u03b5,\n    cases hL \u03b5 h\u03b5 with M hM,\n    use M, intros n hn, simp,\n    have H : c * (a n) = 0, norm_num, left, exact hc, rw H,\n    have G : c * \u03b1 = 0, norm_num, left, exact hc, rw G,\n    norm_num, exact h\u03b5,\n  },\n  { -- this can be merged with first case\n    intros \u03b5 h\u03b5,\n    set e := \u03b5 / c with he,\n    have he_pos := div_pos h\u03b5 hc,\n    cases hL e he_pos with M hM,\n    use M, intros n hn, rw he at hM, simp,\n    have H := hM n hn,\n    have G := (lt_div_iff' hc).mp H,\n    have F := abs_mul c,\n    set b := a n - \u03b1 with hb,\n    have E := F b,\n    have D : |c| = c, exact abs_of_pos hc,\n    rw D at E, rw hb at E,\n    have C := mul_sub c (a n) \u03b1,\n    rw C at E, \n    rw \u2190 hb at E,\n    linarith,\n  }, \n  done", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena -- hide\n\n", "height": 47, "editorText": "sorry", "lineOffset": 18, "name": "lim_times_const", "statement": "(a : \u2115 \u2192 \u211d) (\u03b1 c : \u211d) (hL : is_limit a \u03b1) : \n    is_limit (\u03bb n, c * (a n)) (c*\u03b1)"}, {"type": "lean", "content": "300", "hidden": true}], "url": ""}, {"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "301", "hidden": false}, {"type": "lean", "content": "302", "hidden": true}, {"type": "lean", "content": "303", "hidden": true}, {"type": "text", "content": "304"}, {"type": "lemma", "text": "305", "lean": "lemma lim_linear (a : \u2115 \u2192 \u211d) (b : \u2115 \u2192 \u211d) (\u03b1 \u03b2 c d : \u211d) \n    (ha : is_limit a \u03b1) (hb : is_limit b \u03b2) : \n    is_limit ( \u03bb n, c * (a n) + d * (b n) ) (c * \u03b1 + d * \u03b2) :=\n", "sideBar": true, "firstProofLineNumber": 22, "lastProofLineNumber": 25, "textBefore": "import game.limits.L01defs\nimport game.limits.seq_limitTimesConst\n\nnamespace xena -- hide\n\nnotation `|` x `|` := abs x -- hide\n\n/-\nUse the previous results to obtain linearity.\n-/\n\n\n/- Lemma\nIf $\\lim_{n \\to \\infty} a_n = \\alpha$ and $\\lim_{n \\to \\infty} b_n = \\beta$\nand $c$ is a constant, then \n$\\lim_{n \\to \\infty} ( c * a_n + c * b_n) = c \\alpha + c \\beta$\n-/\nlemma lim_linear (a : \u2115 \u2192 \u211d) (b : \u2115 \u2192 \u211d) (\u03b1 \u03b2 c d : \u211d) \n    (ha : is_limit a \u03b1) (hb : is_limit b \u03b2) : \n    is_limit ( \u03bb n, c * (a n) + d * (b n) ) (c * \u03b1 + d * \u03b2) :=\nbegin\n", "proof": "    apply lim_add,\n    exact lim_times_const a \u03b1 c ha,\n    exact lim_times_const b \u03b2 d hb,\n    done", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena -- hide\n\n", "height": 4, "editorText": "sorry", "lineOffset": 21, "name": "lim_linear", "statement": "(a : \u2115 \u2192 \u211d) (b : \u2115 \u2192 \u211d) (\u03b1 \u03b2 c d : \u211d) \n    (ha : is_limit a \u03b1) (hb : is_limit b \u03b2) : \n    is_limit ( \u03bb n, c * (a n) + d * (b n) ) (c * \u03b1 + d * \u03b2)"}, {"type": "lean", "content": "306", "hidden": true}], "url": ""}, {"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "307", "hidden": false}, {"type": "lean", "content": "308", "hidden": true}, {"type": "lean", "content": "309", "hidden": true}, {"type": "text", "content": "310"}, {"type": "lemma", "text": "311", "lean": "lemma lim_zero_prod (a : \u2115 \u2192 \u211d) (b : \u2115 \u2192 \u211d)\n    (ha : is_limit a 0) (hb : is_limit b 0) : \n    is_limit ( \u03bb n, (a n) * (b n) ) 0 :=\n", "sideBar": true, "firstProofLineNumber": 25, "lastProofLineNumber": 46, "textBefore": "import game.limits.L01defs\nimport game.limits.seq_limitLinear\n\nopen real\n\nnamespace xena -- hide\n\nnotation `|` x `|` := abs x -- hide\n\n/-\nUse previous results to obtain the limit of a product if individual limits\nfor the factors are both zero.\n-/\n\n\n/- Lemma\nIf $\\lim_{n \\to \\infty} a_n = 0$ and $\\lim_{n \\to \\infty} b_n = 0$,\nthen \n$\\lim_{n \\to \\infty} ( a_n * b_n) = 0$\n-/\nlemma lim_zero_prod (a : \u2115 \u2192 \u211d) (b : \u2115 \u2192 \u211d)\n    (ha : is_limit a 0) (hb : is_limit b 0) : \n    is_limit ( \u03bb n, (a n) * (b n) ) 0 :=\nbegin\n", "proof": "    unfold is_limit,\n    intros \u03b5 h\u03b5,\n    set s\u03b5 := sqrt \u03b5 with hs\u03b5, \n    have h1 : 0 < s\u03b5, from  real.sqrt_pos.mpr h\u03b5,\n    have Ha := ha s\u03b5 h1,\n    have Hb := hb s\u03b5 h1,\n    cases Ha with Na hNa,\n    cases Hb with Nb hNb,\n    set N := max Na Nb with hN,\n    use N,\n    intros n hn,\n    have Ha := hNa n (le_of_max_le_left hn),\n    have Hb := hNb n (le_of_max_le_right hn),\n    rw sub_zero at *, rw abs_mul, \n    have g1 := mul_lt_mul_of_pos_right Hb h1,\n    have g2 : s\u03b5 ^ 2 = \u03b5, exact sqr_sqrt( le_of_lt h\u03b5),\n    have g3 : s\u03b5 * s\u03b5 = s\u03b5 ^2, ring,\n    rw g3 at g1, rw g2 at g1, rw mul_comm at g1,\n    have hbn : 0 \u2264 |b n|, exact is_absolute_value.abv_nonneg abs (b n),\n    have G := mul_le_mul_of_nonneg_right (le_of_lt Ha) hbn,\n    exact lt_of_le_of_lt G g1, -- linarith fails!\n    done", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena -- hide\n\n\n", "height": 22, "editorText": "sorry", "lineOffset": 24, "name": "lim_zero_prod", "statement": "(a : \u2115 \u2192 \u211d) (b : \u2115 \u2192 \u211d)\n    (ha : is_limit a 0) (hb : is_limit b 0) : \n    is_limit ( \u03bb n, (a n) * (b n) ) 0"}, {"type": "lean", "content": "312", "hidden": true}], "url": ""}, {"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "313", "hidden": false}, {"type": "lean", "content": "314", "hidden": true}, {"type": "lean", "content": "315", "hidden": true}, {"type": "text", "content": "316"}, {"type": "lemma", "text": "317", "lean": "lemma lim_seq_sub_const (a : \u2115 \u2192 \u211d) (\u03b1 c : \u211d)\n    (ha : is_limit a \u03b1) : \n    is_limit ( \u03bb n, (a n) - c ) (\u03b1 - c) :=\n", "sideBar": true, "firstProofLineNumber": 22, "lastProofLineNumber": 27, "textBefore": "import game.limits.L01defs\nimport game.limits.seq_limitZeroProd\n\nopen real\n\nnamespace xena -- hide\n\nnotation `|` x `|` := abs x -- hide\n\n/-\nUse previous results to obtain the limit of a product in the general case.\n-/\n\n/- Lemma\nIf $\\lim_{n \\to \\infty} a_n = \\alpha$, then \n$\\lim_{n \\to \\infty} (a_n - c) = \\alpha - c.$\n-/\nlemma lim_seq_sub_const (a : \u2115 \u2192 \u211d) (\u03b1 c : \u211d)\n    (ha : is_limit a \u03b1) : \n    is_limit ( \u03bb n, (a n) - c ) (\u03b1 - c) :=\nbegin\n", "proof": "    intros \u03b5 h\u03b5,\n    have H := ha \u03b5 h\u03b5, cases H with N hN,\n    use N, intros n hn, \n    have G := hN n hn, simp,\n    have h : a n - c - (\u03b1 - c) = a n - \u03b1, ring,\n    rw h, exact G, done", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena\n", "height": 6, "editorText": "sorry", "lineOffset": 21, "name": "lim_seq_sub_const", "statement": "(a : \u2115 \u2192 \u211d) (\u03b1 c : \u211d)\n    (ha : is_limit a \u03b1) : \n    is_limit ( \u03bb n, (a n) - c ) (\u03b1 - c)"}, {"type": "lean", "content": "318", "hidden": false}], "url": ""}, {"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "319", "hidden": false}, {"type": "lean", "content": "320", "hidden": true}, {"type": "lean", "content": "321", "hidden": true}, {"type": "text", "content": "322"}, {"type": "lemma", "text": "323", "lean": "lemma lim_prod (a : \u2115 \u2192 \u211d) (b : \u2115 \u2192 \u211d) (\u03b1 \u03b2 : \u211d)\n    (ha : is_limit a \u03b1) (hb : is_limit b \u03b2) : \n    is_limit ( \u03bb n, (a n) * (b n) ) (\u03b1 * \u03b2) :=\n", "sideBar": true, "firstProofLineNumber": 23, "lastProofLineNumber": 64, "textBefore": "import game.limits.L01defs\nimport game.limits.seq_limSeqSub\n\nopen real\n\nnamespace xena -- hide\n\nnotation `|` x `|` := abs x -- hide\n\n/-\nUse previous results to obtain the limit of a product in the general case.\nWork in progress.\n-/\n\n/- Lemma\nIf $\\lim_{n \\to \\infty} a_n = \\alpha$ and $\\lim_{n \\to \\infty} b_n = \\beta$, then \n$\\lim_{n \\to \\infty} (a_n * b_n) = \\alpha * \\beta$\n-/\nlemma lim_prod (a : \u2115 \u2192 \u211d) (b : \u2115 \u2192 \u211d) (\u03b1 \u03b2 : \u211d)\n    (ha : is_limit a \u03b1) (hb : is_limit b \u03b2) : \n    is_limit ( \u03bb n, (a n) * (b n) ) (\u03b1 * \u03b2) :=\nbegin\n", "proof": "    have Ha := lim_seq_sub_const a \u03b1 \u03b1 ha,\n    rw [sub_self \u03b1] at Ha,\n    have Hb := lim_seq_sub_const b \u03b2 \u03b2 hb,\n    rw [sub_self \u03b2] at Hb,\n    have G := lim_zero_prod (\u03bb n, a n - \u03b1) (\u03bb n, b n - \u03b2) Ha Hb,\n    have g1 := lim_times_const a \u03b1 \u03b2 ha,\n    have g2 := lim_times_const b \u03b2 \u03b1 hb,\n    -- becomes ugly, need to improve notation\n    have G1 := lim_linear (\u03bb (n : \u2115), \n        (\u03bb (n : \u2115), a n - \u03b1) n * (\u03bb (n : \u2115), b n - \u03b2) n) a 0 \u03b1 1 \u03b2 G ha,\n    have h1 : (1:\u211d) * 0 + \u03b2 * \u03b1 = \u03b2 * \u03b1 , norm_num,\n    rw h1 at G1,\n    have G2 := lim_linear (\u03bb (n : \u2115), \n        1 * (\u03bb (n : \u2115), (\u03bb (n : \u2115), a n - \u03b1) n * (\u03bb (n : \u2115), b n - \u03b2) n) n + \u03b2 * a n) b \n        (\u03b2 * \u03b1) \u03b2 1 \u03b1 G1 hb,\n    -- to get rid of these non-terminal `simp`\n    simp at G2,\n    have h2 : \u03b2 * \u03b1 + \u03b1 * \u03b2 = 2 * \u03b1 * \u03b2, \n        rw mul_comm \u03b2 \u03b1, norm_num, \n        have h21 := mul_two (\u03b1 * \u03b2), rw \u2190 h21, \n        rw mul_assoc \u03b1 \u03b2 2, rw mul_comm \u03b2 _, rw \u2190 mul_assoc,\n        rw mul_comm \u03b1 2, \n    rw h2 at G2,\n    have G3 := lim_seq_sub_const \n        (\u03bb (n : \u2115), (a n - \u03b1) * (b n - \u03b2) + (\u03b2 * a n + \u03b1 * b n)) (2 * \u03b1 * \u03b2) (\u03b1 * \u03b2) _,\n    simp at G3,\n    have h3 : 2 * \u03b1 * \u03b2 - \u03b1 * \u03b2 = \u03b1 * \u03b2, \n        have h31 : (2:\u211d) * \u03b1 * \u03b2 - \u03b1 * \u03b2 = (2:\u211d) * \u03b1 * \u03b2 + (-1:\u211d) * \u03b1 * \u03b2, ring,\n        --rw \u2190 add_mul (2:\u211d) (-1:\u211d) (\u03b1 * \u03b2) at h31,\n        rw h31, norm_cast, norm_num, ring,\n    rw h3 at G3,\n    intros \u03b5 h\u03b5,\n    have G4 := G3 \u03b5 h\u03b5, cases G4 with N hN,\n    use N,\n    intros n hn,\n    have G5 := hN n hn,\n    simp at G5, simp,\n    have h4 : (a n - \u03b1) * (b n - \u03b2) = (a n) * (b n) - \u03b1 * (b n) - \u03b2 * (a n) + \u03b1 * \u03b2, ring,\n    rw h4 at G5,\n    have h5 : a n * b n - \u03b1 * b n - \u03b2 * a n + \u03b1 * \u03b2 + (\u03b2 * a n + \u03b1 * b n) - \u03b1 * \u03b2 - \u03b1 * \u03b2 =\n        a n * b n - \u03b1 * \u03b2, ring,\n    rw h5 at G5, exact G5, convert G2, ext, ring, done", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena -- hide\n\n\n", "height": 42, "editorText": "sorry", "lineOffset": 22, "name": "lim_prod", "statement": "(a : \u2115 \u2192 \u211d) (b : \u2115 \u2192 \u211d) (\u03b1 \u03b2 : \u211d)\n    (ha : is_limit a \u03b1) (hb : is_limit b \u03b2) : \n    is_limit ( \u03bb n, (a n) * (b n) ) (\u03b1 * \u03b2)"}, {"type": "lean", "content": "324", "hidden": true}], "url": ""}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "325", "hidden": false}, {"type": "lean", "content": "326", "hidden": true}, {"type": "lean", "content": "327", "hidden": true}, {"type": "text", "content": "328"}, {"type": "lean", "content": "329", "hidden": true}, {"type": "lemma", "text": "330", "lean": "theorem limit_check : is_limit (\u03bb n, 1 / n) 0 :=\n", "sideBar": true, "firstProofLineNumber": 21, "lastProofLineNumber": 52, "textBefore": "import game.limits.L01defs\nimport game.limits.seq_limitLinear\n\nnotation `|` x `|` := abs x -- hide\n\nnamespace xena -- hide\n\n/-\nA simple limit proof.\n-/\n\n-- begin hide\n-- The proof below is from M1P1-lean.\n-- end hide\n\n/- Lemma\nProve that the limit of $a_n = 1/n$ is zero.\n-/\ntheorem limit_check : is_limit (\u03bb n, 1 / n) 0 :=\nbegin\n", "proof": "  -- say \u03b5 is a positive real\n  intros \u03b5 H\u03b5,\n  -- we need to find N such that n \u2265 N \u2192 |1 / n| < \u03b5.\n  -- It's a standard fact there exists some integer M \u2265 0\n  -- such that 1 / (M + 1) < \u03b5...\n  cases (exists_nat_one_div_lt H\u03b5) with M HM,\n  -- ...so let's set N = M + 1.\n  let N := M + 1,\n  use N,\n  -- Now say n \u2265 N.\n  intros n Hn, change N \u2264 n at Hn,\n  -- We need to show |1/n| < \u03b5 (because 1/n = 1/n - 0)\n  rw sub_zero, show abs ((1 : \u211d) / n) < \u03b5,\n  -- Because n \u2265 N = M + 1 \u2265 1 > 0, we have n > 0\n  have HM' : 0 < N := lt_of_lt_of_le zero_lt_one (by simp),\n  have HM'' : (0 : \u211d) < N := \n    by rwa [\u2190nat.cast_zero,nat.cast_lt],\n    -- note to self -- Lean rewriting M + 1 as 1 + M\n  have HNn : (N : \u211d) \u2264 n := by rwa nat.cast_le,\n  have Hn'' : 0 < (n : \u211d) := by linarith,\n  -- so 1 / n > 0,\n  have H2 : (1 : \u211d) / n > 0,\n    exact one_div_pos_of_pos Hn'',\n  -- and hence |1 / n| = 1 / n.\n  rw abs_of_pos H2,\n  -- We want to prove 1 / n < \u03b5, but we know 1 / N < \u03b5,\n  -- so it suffices to prove 1 / n \u2264 1 / N\n  suffices : (1 : \u211d) / n \u2264 1 / N,\n    exact lt_of_le_of_lt this HM,\n  -- This follows easily from the fact that N \u2264 n\n  refine div_le_div_of_le_left zero_le_one HM'' HNn,\n  done", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena -- hide\n", "height": 32, "editorText": "sorry", "lineOffset": 20, "name": "limit_check", "statement": "is_limit (\u03bb n, 1 / n) 0"}, {"type": "lean", "content": "331", "hidden": true}], "url": ""}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "332", "hidden": false}, {"type": "lean", "content": "333", "hidden": true}, {"type": "lean", "content": "334", "hidden": true}, {"type": "lean", "content": "335", "hidden": false}, {"type": "lean", "content": "336", "hidden": true}, {"type": "text", "content": "337"}, {"type": "lemma", "text": "338", "lean": "lemma cauchy_is_bdd (a : \u2115 \u2192 \u211d) : \n    is_Cauchy a \u2192 is_bdd a:=\n", "sideBar": true, "firstProofLineNumber": 34, "lastProofLineNumber": 93, "textBefore": "import game.limits.L01defs\nimport game.limits.seq_proveLimit\nimport algebra.pi_instances\nimport game.order.level05\n\n\n--open function\nopen finset\n\nnamespace xena -- hide\n\nnotation `|` x `|` := abs x -- hide\n\ndef is_convergent (a : \u2115 \u2192 \u211d) := \u2203 \u03b1 : \u211d, is_limit a \u03b1 \ndef is_Cauchy (a : \u2115 \u2192 \u211d) := \n  \u2200 \u03b5 : \u211d, 0 < \u03b5 \u2192 \u2203 N : \u2115, \u2200 m n : \u2115, N \u2264 m \u2227 N \u2264 n \u2192 |a m - a n| < \u03b5\ndef is_bdd (a : \u2115 \u2192 \u211d) := \u2203 B > 0, \u2200 n, |a n| \u2264 B \n\n-- begin hide\n-- We may want to skip this in RNG unless we can make it look (or be) easy --?\n-- end hide\n\n/-\nCauchy sequences are bounded.\n\n-/\n\n/- Lemma\nA Cauchy sequence is bounded.\n-/\nlemma cauchy_is_bdd (a : \u2115 \u2192 \u211d) : \n    is_Cauchy a \u2192 is_bdd a:=\nbegin\n", "proof": "  --classical proof for boundedness of Cauchy sequences\n  intro HC,\n  set e := (1:\u211d),\n  have h1e : (0:\u211d) < 1, linarith,\n  have H := HC 1 h1e,\n  cases H with N hN,\n  have G := hN N,\n  -- construct X = {|a0|, |a1|, ...,|am|}\n  let X := finset.image (abs \u2218 a) (finset.range (N + 1)),\n  -- at least a0 is in X\n  have  ha0 : |a 0| \u2208 X := finset.mem_image_of_mem _ (mem_range.2 (nat.zero_lt_succ _)),\n  -- hence the set X is not empty\n  have ha1 : X \u2260 \u2205 := ne_empty_of_mem ha0,\n  have ha2 := nonempty_iff_ne_empty.mpr ha1,\n  -- and therefore has a maximum\n  let B1 := X.max' ha2,\n  -- If n \u2264 m then get a proof that |a n| \u2264 B1.\n  have HB1 : \u2200 n \u2264 N, |a n| \u2264 B1 := \u03bb n Hn, le_max' X ha2 _\n    (mem_image_of_mem _ (mem_range.2 (nat.lt_succ_of_le Hn))),\n  -- term that bounds all members of the sequence\n  set B := max B1 ( |a N| + 1 ) with hB,\n  -- so this will be our bound\n  use B,\n  split,\n  swap,\n  intro n,\n  cases le_or_gt n N with hn1 hn2,\n  { -- n \u2264 N\n    have g1 : | a n | \u2264  B1 := HB1 n hn1,\n    have g2 : B1 \u2264 B := le_max_left _ _, \n    linarith,\n  },\n  { -- n > N\n    have g1 := G n,\n    have g2 : N \u2264 N \u2227 N \u2264 n,\n        split; linarith,\n    have g3 := g1 g2,\n    rw abs_lt at g3,\n    have fact1 := g3.left,\n    have fact2 := g3.right,\n    simp,\n    right,\n    rw abs_le,  -- our abs_le is conditional on 0 \u2264 c - proven in the last section\n    simp,\n    split,\n    {\n    have simplefact1: - a N \u2264 | a N | := neg_le_abs_self (a N),\n    linarith,\n    },   \n    {have simplefact2: a N \u2264 | a N | := le_abs_self(a N),\n    linarith},\n    \n  have simplefact3: 0 \u2264 |a N|, from abs_nonneg (a N),\n  linarith,     \n  },\n  \n  have g1 : |a N| + 1 \u2264 B := le_max_right _ _,\n  have g2: 0 \u2264 |a N|, from abs_nonneg (a N),\n  linarith,\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena -- hide\n\n", "height": 60, "editorText": "sorry", "lineOffset": 33, "name": "cauchy_is_bdd", "statement": "(a : \u2115 \u2192 \u211d) : \n    is_Cauchy a \u2192 is_bdd a"}, {"type": "lean", "content": "339", "hidden": true}], "url": ""}, {"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "340", "hidden": false}, {"type": "lean", "content": "341", "hidden": true}, {"type": "lean", "content": "342", "hidden": true}, {"type": "text", "content": "343"}, {"type": "lemma", "text": "344", "lean": "lemma conv_iff_cauchy (a : \u2115 \u2192 \u211d) : \n    is_convergent a \u2192  is_Cauchy a :=\n", "sideBar": true, "firstProofLineNumber": 22, "lastProofLineNumber": 48, "textBefore": "import game.limits.L01defs\nimport game.limits.seq_cauchyBdd\n\nnamespace xena -- hide\n\nnotation `|` x `|` := abs x -- hide\n\n\n/-\nRelationship convergent/Cauchy sequences.\n\nWork in progress.\n-/\n\n/- Lemma\nA convergent sequence of real numbers is a Cauchy sequence.\nProve \"if and only if\": WIP. \n-/\nlemma conv_iff_cauchy (a : \u2115 \u2192 \u211d) : \n    is_convergent a \u2192  is_Cauchy a :=\nbegin\n", "proof": "  --split,\n  -- left-right implication: just doing convergent -> Cauchy here\n  -- for the other direction should prove boundedness of Cauchy first\n  intros h e he,\n  set e2 := e / 2 with hde2,\n  have he2 : 0 < e2, from half_pos he,\n  cases h with \u03b1 h\u03b1, \n  have H := h\u03b1 e2 he2,\n  cases H with N hN,\n  use N,\n  intros m n hmn,\n  have hm := hN m hmn.1, \n  have hn := hN n hmn.2,\n  have h1 : a m - a n = (a m - \u03b1) + (\u03b1 - a n), ring,\n  have h2 : | (a m - \u03b1) + (\u03b1 - a n) | \u2264 | a m - \u03b1 | + | \u03b1 - a n |,\n    exact abs_add (a m - \u03b1) (\u03b1 - a n),\n  rw h1,\n  have g1 : |a n - \u03b1| = |\u03b1 - a n|, \n    have g11 : a n - \u03b1 = - ( \u03b1 - a n), norm_num,\n    rw g11, exact abs_neg _,\n  rw g1 at hn,\n  linarith,\n  -- right-left implication\n  --intro H,\n  --sorry,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena -- hide\n\n-- begin hide\n--example (a b c d : \u211d) (h1 : a \u2264 b + c) : a - b \u2264 c  := by library_search\n--example ( a : \u211d ) : |a| = | - a | := by library_search\n-- end hide\n\n", "height": 27, "editorText": "sorry", "lineOffset": 21, "name": "conv_iff_cauchy", "statement": "(a : \u2115 \u2192 \u211d) : \n    is_convergent a \u2192  is_Cauchy a"}, {"type": "lean", "content": "345", "hidden": true}, {"type": "lean", "content": "346", "hidden": true}], "url": ""}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "347", "hidden": false}, {"type": "lean", "content": "348", "hidden": true}, {"type": "lean", "content": "349", "hidden": true}, {"type": "text", "content": "350"}, {"type": "text", "content": "351"}, {"type": "text", "content": "352"}, {"type": "lean", "content": "353", "hidden": false}, {"type": "lemma", "text": "354", "lean": "open finset\nlemma bounded_if_convergent (a : \u2115 \u2192 \u211d)\n    (ha : is_convergent a ) : \n    is_bounded a :=\n", "sideBar": true, "firstProofLineNumber": 37, "lastProofLineNumber": 94, "textBefore": "import game.limits.seq_convCauchy\n\nnamespace xena -- hide\n\nnotation `|` x `|` := abs x -- hide\n\n/-\nAnother useful result for working with sequences -- a convergent sequence is bounded.\n-/\n\n/- \nWe define the concepts of a bounded sequence, in much the same way\nthat we defined the concepts of a limit and a convergent sequence. \n-/\n\n/-\nNOTE: limits/seq_cauchyBdd.lean introduces the definition\n\nis_bdd (a : \u2115 \u2192 \u211d) := \u2203 B > 0, \u2200 n, |a n| \u2264 B \n\nHere I omit the B > 0 condition (which follows from properties of abs?)\nBut this level is perhaps superfluous anyway.\n-/\n\ndefinition is_bound (a : \u2115 \u2192 \u211d) (M : \u211d) := \u2200 n, | a n | \u2264 M\ndefinition is_bounded (a : \u2115 \u2192 \u211d) := \u2203 M, is_bound a M\n\n\n/- Lemma\nA convergent sequence is bounded.\n-/\nopen finset\nlemma bounded_if_convergent (a : \u2115 \u2192 \u211d)\n    (ha : is_convergent a ) : \n    is_bounded a :=\nbegin\n", "proof": "\ncases ha with \u03b1 islim,             \nspecialize islim 1 (by linarith),  -- specialise to the case \u03b5 = 1, linarith knows this is OK\ncases islim with N_k HN_k,         -- introduce the natural N_k fulfilling \u03b5 = 1 case\n   \n   -- We use these to show that there is a bound for all terms with index \u2265 N_k \n   -- Then take the max of this bound and the earlier terms.\n\nhave bounds_geq_N_k : \u2200 n \u2265 N_k, |a n| \u2264 | \u03b1 | + 1,    \n\n{\nintros bigN Nisbig,                 -- introduce some bigN \u2265 N_k\nspecialize HN_k bigN,               -- specialize to bigN\nhave fact1:= HN_k(Nisbig),          -- just applying our conditional\nrw abs_lt at fact1,    \n\nrw abs_le,     -- note our abs_le will require us to show c \u2265 0\nsimp,\nsplit,\n        \n    {have smallfact: - \u03b1 \u2264 | \u03b1 | := neg_le_abs_self \u03b1,\n        linarith},   \n        \n    {have smallfact2: \u03b1 \u2264 | \u03b1 | := le_abs_self(\u03b1),\n        linarith}, \n\n-- condition for abs_le\nhave fact: 0 \u2264 |\u03b1|, from abs_nonneg \u03b1,\nlinarith,\n\n},\n\n   --  Having shown that we have a bound for the elements above N_k, we consider the earlier terms\n   --  This section is mostly cribbed from Kevin's M1P1 limits file\n\n   let rangeset := finset.image (abs \u2218 a) (range (N_k + 1)),    -- range (N) is set of nats < N\n\n   have fact4 : |a 0| \u2208 rangeset := finset.mem_image_of_mem _ (mem_range.2 (nat.zero_lt_succ _)), \n   have fact5 : rangeset \u2260 \u2205 := ne_empty_of_mem fact4,        \n   have fact6 := nonempty_iff_ne_empty.mpr fact5,  \n   \n   let Bx := rangeset.max' fact6,                              \n   let B := max Bx ( |\u03b1|  + 1),\n \nuse B,\nintro n,\ncases lt_or_ge n N_k with Hlt Hge,\n\n    simp,\n    left,        \n    have HBx : \u2200 n < N_k, |a n| \u2264 Bx := \u03bb n Hn, le_max' rangeset fact6 _\n    (mem_image_of_mem _ (mem_range.2 (nat.lt_succ_of_lt Hn))),   \n    apply HBx,               \n    exact Hlt,         \n    \n    have h2 : |a n| \u2264 |\u03b1| + 1 := bounds_geq_N_k n Hge,\n    have h3 : |\u03b1| + 1 \u2264 B := le_max_right _ _,\n    linarith,", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena -- hide\n", "height": 58, "editorText": "sorry", "lineOffset": 36, "name": "finset", "statement": "lemma bounded_if_convergent (a : \u2115 \u2192 \u211d)\n    (ha : is_convergent a ) : \n    is_bounded a"}, {"type": "lean", "content": "355", "hidden": true}], "url": ""}, {"name": "", "problemIndex": 2, "objects": [{"type": "lean", "content": "356", "hidden": false}, {"type": "text", "content": "357"}, {"type": "lemma", "text": "358", "lean": "lemma shift_rule (a : \u2115 \u2192 \u211d) (k : \u2115) (L : \u211d): \n     is_limit a L \u2194 is_limit (\u03bb (n : \u2115), a (n+k)) L :=\n", "sideBar": true, "firstProofLineNumber": 17, "lastProofLineNumber": 46, "textBefore": "import game.limits.bounded_if_convergent\n\nnamespace xena\n/- \n\"Shift rule\" for sequences, used in Series world:\n-/\n\n/- Lemma\nShift rule\n-/\n\n\nlemma shift_rule (a : \u2115 \u2192 \u211d) (k : \u2115) (L : \u211d): \n     is_limit a L \u2194 is_limit (\u03bb (n : \u2115), a (n+k)) L :=\n\nbegin\n", "proof": "split,\n     {\n     intro hlim,\n     intros e he,\n     unfold is_limit at hlim,\n     specialize hlim e he, \n     cases hlim with N_1 hypN_1,\n     use N_1,\n     intros n hn,\n     simp,\n     have fact : N_1 \u2264 n + k, linarith,\n     specialize hypN_1 (n + k) fact,\n     exact hypN_1,\n     },\n\n     {\n     intro hlim,\n     intros \u03b5 h\u03b5,\n     unfold is_limit at hlim,\n     specialize hlim \u03b5 h\u03b5, \n     cases hlim with N_2 hypN_2,\n     use (k+ N_2),\n     intros N hN,\n     have fact : N_2 \u2264 N - k, from nat.le_sub_left_of_add_le hN,  -- namespace issue here?\n     specialize hypN_2 (N -k) fact,\n     rw nat.sub_add_cancel at hypN_2, -- seems to need these nat. theorems\n     exact hypN_2,\n     linarith,\n     }\n     ", "proof_hint": "sorry", "textAfter": "\nend\nend xena\n", "height": 30, "editorText": "sorry", "lineOffset": 16, "name": "shift_rule", "statement": "(a : \u2115 \u2192 \u211d) (k : \u2115) (L : \u211d): \n     is_limit a L \u2194 is_limit (\u03bb (n : \u2115), a (n+k)) L"}, {"type": "lean", "content": "359", "hidden": false}], "url": ""}, {"name": "", "problemIndex": 3, "objects": [{"type": "lean", "content": "360", "hidden": false}, {"type": "lean", "content": "361", "hidden": true}, {"type": "text", "content": "362"}, {"type": "lemma", "text": "363", "lean": "theorem seq_bdd_iff_range_bdd (a : \u2115 \u2192 \u211d) : is_bounded a \u2194 \nis_bdd_above (set.range a) \u2227 is_bdd_below (set.range a):=\n", "sideBar": true, "firstProofLineNumber": 19, "lastProofLineNumber": 86, "textBefore": "import game.limits.shift_rule_seq\n\nnamespace xena --hide \n\n/- \nBounded monotone sequences converge\n-/\n\n/- Lemma\nIt is obvious that a sequence of real numbers is bounded if and only if \nthe set of its terms is bounded above and bounded below in \u211d. For that\nreason you may wish to skip the proof of the following proposition, which \nwe will use in our proof of the monotone convergence theorem.\n-/\n\ntheorem seq_bdd_iff_range_bdd (a : \u2115 \u2192 \u211d) : is_bounded a \u2194 \nis_bdd_above (set.range a) \u2227 is_bdd_below (set.range a):=\nbegin\n", "proof": "-- first split the iff\nsplit,\n    -- Sequence bounded only if range bounded above and below (\u2192)\n    {\n    -- let |a n| \u2264 B for any n, from def of bounded sequence\n    intro hyp,\n    cases hyp with B hypB,\n    -- now split the conjunction\n    split,\n        -- first prove set of terms is bounded above\n        {\n        use B,\n        -- let s be any element in our set of terms\n        intros s hyp,\n        -- by definition of set.range, hyp proves \u2203 (k : \u2115), a k = s,\n        cases hyp with k hypk,\n        specialize hypB k,\n        -- establish a simple fact and use linarith\n        have fact: a k \u2264 |a k|, from le_abs_self (a k),\n        linarith,\n        },\n        -- set of terms is bounded below, similar proof\n        {\n        use -B,\n        intros s hyp,\n        cases hyp with k hypk,\n        specialize hypB k,\n        refine neg_le.mp _,   -- makes goal a litle clearer\n        have fact:= neg_le_abs_self (a k),\n        linarith,\n        }\n    },\n    -- Sequence bounded if range bounded above and below (\u2190)\n    intro hyp,\n    -- set up our upper and lower bounds for the range\n    cases hyp.left with U hypU,\n    cases hyp.right with L hypL,\n    -- Use max and abs to define a term B to bound our sequence\n    let B := max U (|L|),\n    use B,\n    -- Now show that this B is a bound\n    intro k,\n    -- k defines an arbitrary term a k in our sequence\n    have fact: a k \u2208 set.range a, exact set.mem_range_self k,\n    -- we know that U and L are upper and lower bounds for the range \n    have Upperbound: a k \u2264 U, from hypU (a k) fact,\n    have Lowerbound: L \u2264 a k, from hypL (a k) fact,\n    -- refine unfolds consequences of the `max` function hidden \n    -- inside `B` in our goal (I used `suggest` here)\n    refine le_max_iff.mpr _,\n    -- to prove |a k| \u2264 B, we proceed by cases on the sign of a k \n    by_cases sign : 0 \u2264 a k, \n    -- a k is non-negative, so the corresponding bound is U\n    {-- so choose `left`\n    left,\n    have: |a k| = a k, from abs_of_nonneg sign,\n    linarith,\n    },\n    -- a k is negative, so the corresponding bound is |L|\n    -- again, prepare simple facts about `abs` and use linarith\n    {\n    right,\n    simp at sign,\n    have fact1:= abs_of_neg sign,\n    have Lisneg:= lt_of_le_of_lt Lowerbound sign,\n    have fact2:= abs_of_neg Lisneg,\n    linarith,\n    }", "proof_hint": "sorry", "textAfter": "\nend\n\n\nend xena -- hide\n", "height": 68, "editorText": "sorry", "lineOffset": 18, "name": "seq_bdd_iff_range_bdd", "statement": "(a : \u2115 \u2192 \u211d) : is_bounded a \u2194 \nis_bdd_above (set.range a) \u2227 is_bdd_below (set.range a)"}, {"type": "lean", "content": "364", "hidden": true}], "url": ""}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "365", "hidden": false}, {"type": "lean", "content": "366", "hidden": true}, {"type": "text", "content": "367"}, {"type": "lean", "content": "368", "hidden": false}, {"type": "lean", "content": "369", "hidden": true}, {"type": "lemma", "text": "370", "lean": "theorem bdd_mono_converges (a : \u2115 \u2192 \u211d) (h1 : is_bounded a) (h2 : is_monotone a): \nis_convergent a :=\n", "sideBar": true, "firstProofLineNumber": 53, "lastProofLineNumber": 157, "textBefore": "import game.limits.seq_bdd_iff_range_bdd\n\nnamespace xena --hide \n\n/- \nBounded monotone sequences converge\n-/\n\ndef is_increasing (a : \u2115 \u2192 \u211d) := \u2200 n : \u2115, a n \u2264 a (n+1)\ndef is_decreasing (a : \u2115 \u2192 \u211d) := \u2200 n : \u2115, a (n + 1) \u2264 a n\ndef is_monotone (a : \u2115 \u2192 \u211d) := is_increasing a \u2228 is_decreasing a\n\n-- begin hide\n-- Note: later we use (n \u2264 k) \u2192 (a n \u2264 a k) for `a` monotone increasing\n-- and (n \u2264 k) \u2192 (a k \u2264 a n) for decreasing. Should these be proved first,\n-- or use mathlib's versions of monotone? \n--https://leanprover-community.github.io/mathlib_docs/order/basic.html\n\ntheorem is_increasing' (a : \u2115 \u2192 \u211d) : is_increasing a \u2194 (\u2200 m n : \u2115, \n m \u2264 n \u2192 a m \u2264 a n) := \nbegin\nsplit,\nintros inc m n,\n{intro hyp,\ninduction hyp with k hyp ihyp,\nexact le_refl (a m),\nexact le_trans ihyp (inc k),},\nintros hyp p,\nexact (hyp p (p + 1)) (nat.le_succ p),\nend\n\ntheorem is_decreasing' (a : \u2115 \u2192 \u211d) : is_decreasing a \u2194 (\u2200 m n : \u2115, \n m \u2264 n \u2192 a n \u2264 a m) := \nbegin\nsplit,\nintros dec m n,\n{intro hyp,\ninduction hyp with k hyp ihyp,\nexact le_refl (a m),\nexact le_trans (dec k) ihyp,},\nintros hyp p,\nexact (hyp p (p + 1)) (nat.le_succ p),\nend\n-- end hide\n\n/- Lemma\nBounded monotone sequences converge. \n-/\n\ntheorem bdd_mono_converges (a : \u2115 \u2192 \u211d) (h1 : is_bounded a) (h2 : is_monotone a): \nis_convergent a :=\nbegin\n", "proof": "-- As before, M is the set of terms of our sequence a\nlet M := set.range a,\n\n-- The increasing and the decreasing cases will be similar\ncases h2 with increasing decreasing,\n    \n    -- monotone increasing case\n    {\n    have fact1: has_lub M,\n    -- We use the completeness axiom (least upper bound property)\n    -- to show that M has a sup. refine produces two subgoals that we \n    -- will need to prove to show that the sup exists.\n    refine lub_property_reals M _,\n\n    split,\n        -- As our sequence `a` is a function from the nonempty set \u2115, \n        -- its range is nonempty\n        {\n        exact set.range_nonempty a,\n        },\n        -- We use the \u2192 (.mp) direction of our previous `trivial` lemma \n        -- to prove that M is bounded above\n        {exact ((seq_bdd_iff_range_bdd a).mp h1).left,\n        },\n\n    -- So M has a lub, call it s.\n    cases fact1 with s hyp_s,\n    \n    -- It seems reasonable to assume that s is the limit of a\n    use s,\n    intros e hype,\n\n    -- We show that s - e cannot be an upper bound for M (our set of terms)\n    have fact2: \u00ac is_upper_bound M (s - e),\n    by_contradiction claim,\n    -- hyp_s.right says if y is any upper bound of M, then s \u2264 y \n    -- (supremum condition)\n    let forcontra := hyp_s.right (s - e) claim,\n    --forcontra says that s \u2264 s - e. But e is positive, so linarith closes.\n    linarith,\n    \n    -- we now unfold the fact that s - e is not an upper bound for M,\n    -- and prove that s is the limit of our increasing sequence\n    unfold is_upper_bound at fact2,\n    push_neg at fact2,\n    cases fact2 with l hypl,\n    -- hypl.right is a proof that s - e < l, for some l \u2208 M\n    -- we want l expressed in the form a N0 for some N0,\n    cases hypl.left with N0 hypN0,\n    use N0,\n    intros k hypk,\n    -- applying the theorem proved above\n    rw is_increasing' at increasing, \n    have fact3:= (increasing N0 k) hypk,\n    refine abs_lt.mpr _,\n    split, \n    linarith,\n    have fact4: a k \u2264 s, \n    exact hyp_s.left (a k) (set.mem_range_self k),\n    linarith,\n    },\n\n    --monotone decreasing case, using the same strategy\n    {\n    have fact3: has_glb M,\n    refine glb_property_reals M _,\n\n    split,\n        {\n        exact set.range_nonempty a,\n        },\n\n        {\n        exact ((seq_bdd_iff_range_bdd a).mp h1).right,\n        },\n\n    cases fact3 with i hyp_i,\n    use i,\n\n    intros e hype,\n\n    -- We show that i + e cannot be a lower bound for M (our set of terms)\n    have fact4: \u00ac is_lower_bound M (i + e),\n    by_contradiction claim,\n    let forcontra := hyp_i.right (i + e) claim,\n    linarith,\n\n    unfold is_lower_bound at fact4,\n    push_neg at fact4,\n    cases fact4 with m hypm,\n \n    cases hypm.left with N0 hypN0,\n    use N0,\n    intros k hypk,\n    -- applying the theorem proved above\n    rw is_decreasing' at decreasing, \n    have fact5:= (decreasing N0 k) hypk,\n    refine abs_lt.mpr _,\n    split, \n    have fact4: i \u2264 a k, \n    exact hyp_i.left (a k) (set.mem_range_self k),\n    linarith,\n    linarith,\n    },\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena -- hide\n", "height": 105, "editorText": "sorry", "lineOffset": 52, "name": "bdd_mono_converges", "statement": "(a : \u2115 \u2192 \u211d) (h1 : is_bounded a) (h2 : is_monotone a): \nis_convergent a"}, {"type": "lean", "content": "371", "hidden": true}], "url": ""}], "parents": [2]}, {"name": "372", "levels": [{"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "373", "hidden": false}, {"type": "lean", "content": "374", "hidden": true}, {"type": "text", "content": "375"}, {"type": "lean", "content": "376", "hidden": false}, {"type": "lemma", "text": "377", "lean": "lemma seqlim_0_if_sum_converges (a : \u2115 \u2192 \u211d) : \n      series_converges a \u2192 is_limit a 0 :=\n", "sideBar": true, "firstProofLineNumber": 33, "lastProofLineNumber": 72, "textBefore": "import game.series.L01defs\n\nnamespace xena \n\n-- begin hide\n-- if we want to use sigma notation, use \n-- import algebra.big_operators\n-- open_locale big_operators \n-- https://leanprover-community.github.io/mathlib_docs/algebra/big_operators.html\n-- end hide\n\n/- \nIf $\\sum a_n$ converges, then $a_n \\to 0$.\n\nWe take the approach of showing that $(S_n) \u2192 M$ then $(S_{n+1}) \u2192 M$,\nand then using the fact that $a_{n+1} = S_{n+1} - S_n$.\n-/\n\ndef kth_partial_sum (a : \u2115 \u2192 \u211d) (k : \u2115) := (finset.range (k+1)).sum a\n\ndef seq_partials_over (a : \u2115 \u2192 \u211d ) : \u2115 \u2192 \u211d := (\u03bb (n : \u2115), kth_partial_sum a n )\n\ndef series_converges (a : \u2115 \u2192 \u211d) := is_convergent (seq_partials_over a)\n\n/- Lemma\nIf partial sum sequence of $a_n$ convergent, $a_n \u2192 0$.\n-/\n\nlemma seqlim_0_if_sum_converges (a : \u2115 \u2192 \u211d) : \n      series_converges a \u2192 is_limit a 0 :=\n\nbegin\n", "proof": "\nintro h,\ncases h with M Mislimit,\n\n-- shift_rule to show that shifted sequence of partial sums also tends to M\nhave fact := shift_rule (seq_partials_over a) 1 M,\nhave fact2 := iff.mp fact Mislimit,\n\n-- express `a (m+1)` using partial sums, sum_range_succ seems best way\nhave fact3 : \u2200 m : \u2115, kth_partial_sum a (m+1) \n= a (m+1) +  kth_partial_sum a (m),\nintro m, from finset.sum_range_succ a (m+1),\n\n--we really want fact4, but sum_range_succ couldn't do it directly?\nhave fact4 : \u2200 (m : \u2115), a (m + 1) = kth_partial_sum a (m+1) - kth_partial_sum a (m),\nintro n,              \nspecialize fact3 n,   -- do I need to do this to reorganise inside quantiifer?\nlinarith,       \n\n-- we can rewrite our goal in terms of `a` shifted by +1\nhave fact5 : is_limit a 0 \u2194 is_limit (\u03bb (m : \u2115), a (m+1)) 0,\n     from shift_rule a 1 0,\nrw fact5,\n\nhave fact6: \n(\u03bb (n : \u2115), a (n + 1)) = \u03bb (n: \u2115), (kth_partial_sum a (n + 1) - kth_partial_sum a n),\nexact funext fact4,  -- suggest gave me this!\n\nrw fact6,\n\nunfold seq_partials_over at Mislimit fact2, -- just for clarity\n\nhave fact7 := lim_linear \n(\u03bb (n : \u2115), kth_partial_sum a (n + 1))\n(\u03bb (n : \u2115), kth_partial_sum a n)\nM M 1 (-1) fact2 Mislimit,\n\nsimp at fact7,\nexact fact7,\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena\n", "height": 40, "editorText": "sorry", "lineOffset": 32, "name": "seqlim_0_if_sum_converges", "statement": "(a : \u2115 \u2192 \u211d) : \n      series_converges a \u2192 is_limit a 0"}, {"type": "lean", "content": "378", "hidden": false}], "url": ""}, {"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "379", "hidden": false}, {"type": "lean", "content": "380", "hidden": true}, {"type": "lean", "content": "381", "hidden": false}, {"type": "text", "content": "382"}, {"type": "lemma", "text": "383", "lean": "theorem subset_union_left (A B : set X) : A \u2286 A \u222a B :=\n", "sideBar": true, "firstProofLineNumber": 18, "lastProofLineNumber": 20, "textBefore": "import game.series.tempLevel01\nvariable X : Type --hide\n\nnamespace xena\n\n/- \nIdea 02: if $\\forall n \\in \\mathbb{N}, a_n \\ge 0$,\n$\\sum a_n$ converges iff partial sums bounded above.\n-/\n\n\n/- Lemma\nIf $A$ and $B$ are sets of any type $X$, then\n$$ A \\subseteq A\\cup B.$$ \n-/\ntheorem subset_union_left (A B : set X) : A \u2286 A \u222a B :=\nbegin\n", "proof": "    --change \u2200 (x : \u03b1), x \u2208 A \u2192 x \u2208 A \u222a B,  --they may want to do this\n    intros x hx,\n    left, exact hx, done", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena", "height": 3, "editorText": "sorry", "lineOffset": 17, "name": "subset_union_left", "statement": "(A B : set X) : A \u2286 A \u222a B"}, {"type": "lean", "content": "384", "hidden": false}], "url": ""}, {"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "385", "hidden": false}, {"type": "lean", "content": "386", "hidden": true}, {"type": "lean", "content": "387", "hidden": false}, {"type": "text", "content": "388"}, {"type": "lemma", "text": "389", "lean": "theorem comparison_test (a b : \u2115 \u2192 \u211d) \n(h1 : \u2200 (n : \u2115), 0 \u2264 a n)\n(h2 : \u2200 (n : \u2115), a n \u2264 b n) : \nseries_converges b \u2192 series_converges a :=\n", "sideBar": true, "firstProofLineNumber": 21, "lastProofLineNumber": 92, "textBefore": "import game.series.tempLevel02\nvariable X : Type --hide\n\nnamespace xena\n\n/- \nIdea 03: comparison test\n-/\n\n/- Lemma\nSuppose $0 \u2264 a_n \u2264 b_n$ for all n \u2208 \u2115. If $\u2211 b_n$ converges\nthen $\u2211 a_n$ converges and $\u2211 a_n \u2264 \u2211 b_n$.\n-/\n\ntheorem comparison_test (a b : \u2115 \u2192 \u211d) \n(h1 : \u2200 (n : \u2115), 0 \u2264 a n)\n(h2 : \u2200 (n : \u2115), a n \u2264 b n) : \nseries_converges b \u2192 series_converges a :=\n\nbegin\n", "proof": "\n--introduce hyp that series over b converges, with sum S\nintro hyp,\n\n-- we will use the following fact later\n-- our converging sequence of partials must be bounded\nhave fact := bounded_if_convergent (seq_partials_over b) hyp,\n\ncases hyp with S hypS,\n    \n    --show that partial sums over a are all positive\n    have fact1: \u2200 k : \u2115, (0 \u2264 kth_partial_sum a k),\n    unfold kth_partial_sum, -- just making finset explicit\n    intro k,\n\n        have fact2: \u2200 x \u2208 (finset.range (k + 1)), 0 \u2264 a x,\n        intros x hx,\n        specialize h1 x, exact h1,\n        \n    apply finset.sum_nonneg,\n    exact fact2,\n    \n    --show that nth partial sum over a \u2264 nth partial sum over b\n    have fact3: \u2200 k : \u2115, \n    kth_partial_sum a k \u2264 kth_partial_sum b k,\n    intro k,\n    \n        have fact4: \u2200 x \u2208 (finset.range (k + 1)), a x \u2264 b x,\n        intros x hx,\n        specialize h2 x, exact h2,\n\n    apply finset.sum_le_sum,\n    exact fact4,    \n    \n-- Although we know that our series over b converges with sum S\n-- we use the fact that the sequence of sums must be bounded \n-- by *some* T (i.e. we don't use the fact that S is the supremum)\n\ncases fact with T hypT,\n-- hypT is stated in terms of `abs`\n-- so our partial sums over b are bounded above \nhave fact5: \u2200 k : \u2115, kth_partial_sum b k \u2264 T,\nunfold seq_partials_over at hypT,\nintro K,\nhave fact6: kth_partial_sum b K \u2264 |kth_partial_sum b K|,\nexact le_abs_self (kth_partial_sum b K),\nhave :=  hypT K,\nlinarith,\n-- so our partial sums over a are bounded above \nhave fact7 : \u2200 k : \u2115, kth_partial_sum a k \u2264 T,\nintro k, specialize fact3 k, specialize fact5 k, linarith,\n-- bdd_mono_converges is the relevant theorem now.\n-- but it uses absolute values, so we will need to\n-- do a little more work using some facts proved above\nrefine bdd_mono_converges (seq_partials_over a) _ _,\nunfold seq_partials_over,\nuse T,\nintro m,\nlet fact8 := fact7 m,\nrefine max_le (fact7 m) _,\nhave fact9 := fact1 m,\nlinarith,\n\nunfold is_monotone,\nleft,\nintro n,\nunfold seq_partials_over,\nlet fact10 := finset.sum_range_succ a (n+1),\nhave fact11 := h1 (n + 1), \nunfold kth_partial_sum,\nlinarith,\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena", "height": 72, "editorText": "sorry", "lineOffset": 20, "name": "comparison_test", "statement": "(a b : \u2115 \u2192 \u211d) \n(h1 : \u2200 (n : \u2115), 0 \u2264 a n)\n(h2 : \u2200 (n : \u2115), a n \u2264 b n) : \nseries_converges b \u2192 series_converges a"}, {"type": "lean", "content": "390", "hidden": false}], "url": ""}, {"name": "", "problemIndex": 3, "objects": [{"type": "lean", "content": "391", "hidden": false}, {"type": "lean", "content": "392", "hidden": true}, {"type": "text", "content": "393"}, {"type": "lemma", "text": "394", "lean": "theorem subset_union_left (A B : set X) : A \u2286 A \u222a B :=\n", "sideBar": true, "firstProofLineNumber": 15, "lastProofLineNumber": 17, "textBefore": "import game.series.L01defs\nvariable X : Type --hide\n\n/- \nIdea 04: root test\n-/\n\n\n/- Lemma\nIf $A$ and $B$ are sets of any type $X$, then\n$$ A \\subseteq A\\cup B.$$ \n-/\ntheorem subset_union_left (A B : set X) : A \u2286 A \u222a B :=\nbegin\n", "proof": "    --change \u2200 (x : \u03b1), x \u2208 A \u2192 x \u2208 A \u222a B,  --they may want to do this\n    intros x hx,\n    left, exact hx, done", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 3, "editorText": "sorry", "lineOffset": 14, "name": "subset_union_left", "statement": "(A B : set X) : A \u2286 A \u222a B"}], "url": ""}], "parents": [3]}, {"name": "395", "levels": [{"name": "", "problemIndex": 2, "objects": [{"type": "lean", "content": "396", "hidden": false}, {"type": "text", "content": "397"}, {"type": "lemma", "text": "398", "lean": "theorem both_injective \n    (X Y Z : set \u211d) (f : X \u2192 Y) (g : Y \u2192 Z) : injective f \u2227 injective g \u2192 injective (g \u2218 f) :=\n", "sideBar": true, "firstProofLineNumber": 20, "lastProofLineNumber": 24, "textBefore": "import data.real.basic\nopen function\n\n/-\n# Chapter 6 : Functions\n\n## Level 1\n\nA classical result in composition of functions.\n-/\n\n\n/- Lemma\nIf $f : X \\to Y$ and $g : Y \\to Z$ are both injective functions, then\nthe function resulting from their composition is also injective.\n-/\ntheorem both_injective \n    (X Y Z : set \u211d) (f : X \u2192 Y) (g : Y \u2192 Z) : injective f \u2227 injective g \u2192 injective (g \u2218 f) :=\nbegin\n", "proof": "    intros h a b ha,\n    apply h.left,\n    apply h.right, \n    --either this: assumption, --or the line below\n    exact ha, done", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 5, "editorText": "sorry", "lineOffset": 19, "name": "both_injective", "statement": "(X Y Z : set \u211d) (f : X \u2192 Y) (g : Y \u2192 Z) : injective f \u2227 injective g \u2192 injective (g \u2218 f)"}], "url": ""}, {"name": "", "problemIndex": 2, "objects": [{"type": "lean", "content": "399", "hidden": false}, {"type": "text", "content": "400"}, {"type": "lemma", "text": "401", "lean": "theorem both_surjective\n    (X Y Z : set \u211d) (f : X \u2192 Y) (g : Y \u2192 Z) : \n    surjective f \u2227 surjective g \u2192 surjective (g \u2218 f) :=\n", "sideBar": true, "firstProofLineNumber": 20, "lastProofLineNumber": 26, "textBefore": "import data.real.basic\nopen function\n\n/-\n# Chapter 6 : Functions\n\n## Level 2\n\nA classical result in composition of functions.\n-/\n\n/- Lemma\nIf $f : X \\to Y$ and $g : Y \\to Z$ are both surjective functions, then\nthe function resulting from their composition is also surjective.\n-/\ntheorem both_surjective\n    (X Y Z : set \u211d) (f : X \u2192 Y) (g : Y \u2192 Z) : \n    surjective f \u2227 surjective g \u2192 surjective (g \u2218 f) :=\nbegin\n", "proof": "    intros H z,\n    cases H with sf sg,\n    have hy : \u2203 y : Y, g y = z, from sg z,\n    cases hy with y gy,\n    have hx : \u2203 x : X, f x = y, from sf y,\n    cases hx with x fx,\n    use x, rw \u2190 gy, rw \u2190 fx, done", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 7, "editorText": "sorry", "lineOffset": 19, "name": "both_surjective", "statement": "(X Y Z : set \u211d) (f : X \u2192 Y) (g : Y \u2192 Z) : \n    surjective f \u2227 surjective g \u2192 surjective (g \u2218 f)"}], "url": ""}, {"name": "", "problemIndex": 2, "objects": [{"type": "lean", "content": "402", "hidden": false}, {"type": "text", "content": "403"}, {"type": "lemma", "text": "404", "lean": "theorem both_bijective\n    (X Y Z : set \u211d) (f : X \u2192 Y) (g : Y \u2192 Z) : \n    bijective f \u2227 bijective g \u2192 bijective (g \u2218 f) :=\n", "sideBar": true, "firstProofLineNumber": 21, "lastProofLineNumber": 32, "textBefore": "import data.real.basic\nimport game.functions.bothInjective game.functions.bothSurjective\nopen function\n\n/-\n# Chapter 6 : Functions\n\n## Level 3\n\nBe sure to make use of the results in the previous two levels.\n-/\n\n/- Lemma\nIf $f : X \\to Y$ and $g : Y \\to Z$ are both bijective functions, then\nthe function resulting from their composition is also bijective.\n-/\ntheorem both_bijective\n    (X Y Z : set \u211d) (f : X \u2192 Y) (g : Y \u2192 Z) : \n    bijective f \u2227 bijective g \u2192 bijective (g \u2218 f) :=\nbegin\n", "proof": "    -- Since $f$ and $g$ are bijective, they are also both injective and surjective.\n    rintro \u27e8\u27e8hfi, hfs\u27e9, hgi, hgs\u27e9,\n    split,\n    -- Since $f$ and $g$ are injective, $g \u2218 f$ is injective by a previous result.\n    apply both_injective,\n    split,\n    repeat {assumption},\n    -- Similarly, since $f$ and $g$ are surjective, $g \u2218 f$ is surjective.\n    apply both_surjective,\n    split,\n    -- Hence, since $g \u2218 f$ is injective and surjective, $g \u2218 f$ is bijective.\n    repeat {assumption}, done", "proof_hint": "sorry", "textAfter": "\nend\n\n", "height": 12, "editorText": "sorry", "lineOffset": 20, "name": "both_bijective", "statement": "(X Y Z : set \u211d) (f : X \u2192 Y) (g : Y \u2192 Z) : \n    bijective f \u2227 bijective g \u2192 bijective (g \u2218 f)"}], "url": ""}, {"name": "", "problemIndex": 3, "objects": [{"type": "lean", "content": "405", "hidden": false}, {"type": "text", "content": "406"}, {"type": "lean", "content": "407", "hidden": false}, {"type": "lemma", "text": "408", "lean": "theorem exist_two_sided_inverse (X Y : set \u211d) (f : X \u2192 Y) : \n    (\u2203 g : Y \u2192 X, two_sided_inverse f g) \u2194 bijective f :=\n", "sideBar": true, "firstProofLineNumber": 22, "lastProofLineNumber": 58, "textBefore": "import data.real.basic\nopen function\n\n/-\n# Chapter 6 : Functions\n\n## Level 4\n\nA classical result in composition of functions.\n-/\n\n-- inverses\ndef two_sided_inverse {X Y : set \u211d} (f : X \u2192 Y) (g : Y \u2192 X) \n:= (\u2200 x : X, (g \u2218 f)(x) = x) \u2227 (\u2200 y : Y, (f \u2218 g)(y) = y)\n\n/- Lemma\nA function $f : X \u2192 Y$ has a two-sided inverse if and only if it is a bijection.\n-/\ntheorem exist_two_sided_inverse (X Y : set \u211d) (f : X \u2192 Y) : \n    (\u2203 g : Y \u2192 X, two_sided_inverse f g) \u2194 bijective f :=\nbegin\n", "proof": "    split,\n    {\n        intro Eg,\n        cases Eg with g invg,\n        cases invg with gf fg,\n        -- show f is injective\n        have hinjf : injective f,\n            intros x1 x2 f1f2,\n            replace f1f2 : g ( f x1 ) = g ( f x2 ),\n            rw f1f2,\n            have h1 : g (f x1) = x1 := gf x1,\n            have h2 : g (f x2) = x2 := gf x2,\n            rw [ h1, h2 ] at f1f2, exact f1f2,\n        -- show f is surjective \n        have hsurf : surjective f,\n            intro y,\n            existsi g y,\n            exact fg y,\n        -- put these results together\n        exact and.intro hinjf hsurf,\n    },\n    {\n        rintro bf,\n        cases bf with finj fsurj,\n        -- Since $f$ is surjective, $\u2200 y \u2208 Y, \u2203 x \u2208 X$ such that $f(x) = y$; \n        -- choose this $x$ to be the output of $g(y)$.\n        choose g hg using fsurj,\n        existsi g,\n        split,\n        intro x,\n        -- by definition of $g$, $\u2200 y \u2208 Y, f(g(y)) = y$ \n        -- so we have $f(g(f(x))) = f(x)$:\n        have hx : f (g (f x)) = f x, rw hg (f x),\n        apply finj, \n        exact hx,\n        exact hg,\n    }", "proof_hint": "sorry", "textAfter": "\nend\n\n", "height": 37, "editorText": "sorry", "lineOffset": 21, "name": "exist_two_sided_inverse", "statement": "(X Y : set \u211d) (f : X \u2192 Y) : \n    (\u2203 g : Y \u2192 X, two_sided_inverse f g) \u2194 bijective f"}], "url": ""}, {"name": "", "problemIndex": 2, "objects": [{"type": "lean", "content": "409", "hidden": false}, {"type": "text", "content": "410"}, {"type": "lemma", "text": "411", "lean": "theorem composition_injective \n    (X Y Z : set \u211d) (f : X \u2192 Y) (g : Y \u2192 Z) : injective (g \u2218 f) \u2192 injective f :=\n", "sideBar": true, "firstProofLineNumber": 19, "lastProofLineNumber": 23, "textBefore": "import data.real.basic\nopen function\n\n/-\n# Chapter 6 : Functions\n\n## Level 5\n\nA classical result in composition of functions.\nNow going the other way around.\n-/\n\n/- Lemma\nIf composition of $f$ and $g$ is injective, then $f$ is injective.\n-/\ntheorem composition_injective \n    (X Y Z : set \u211d) (f : X \u2192 Y) (g : Y \u2192 Z) : injective (g \u2218 f) \u2192 injective f :=\nbegin\n", "proof": "    intros h a b ha,\n    have applyg : g (f a) = g (f a), refl,\n    rw ha at applyg {occs := occurrences.pos [2]},\n    apply h,\n    exact applyg, done ", "proof_hint": "sorry", "textAfter": "\nend\n\n", "height": 5, "editorText": "sorry", "lineOffset": 18, "name": "composition_injective", "statement": "(X Y Z : set \u211d) (f : X \u2192 Y) (g : Y \u2192 Z) : injective (g \u2218 f) \u2192 injective f"}], "url": ""}, {"name": "", "problemIndex": 2, "objects": [{"type": "lean", "content": "412", "hidden": false}, {"type": "text", "content": "413"}, {"type": "lemma", "text": "414", "lean": "theorem composition_surjective \n    (X Y Z : set \u211d) (f : X \u2192 Y) (g : Y \u2192 Z) : surjective (g \u2218 f) \u2192 surjective g :=\n", "sideBar": true, "firstProofLineNumber": 19, "lastProofLineNumber": 23, "textBefore": "import data.real.basic\nopen function\n\n/-\n# Chapter 6 : Functions\n\n## Level 6\n\nA classical result in composition of functions.\nNow going the other way around.\n-/\n\n/- Lemma\nIf composition of $f$ and $g$ is surjective, then $g$ is injective.\n-/\ntheorem composition_surjective \n    (X Y Z : set \u211d) (f : X \u2192 Y) (g : Y \u2192 Z) : surjective (g \u2218 f) \u2192 surjective g :=\nbegin\n", "proof": "    intros sgf z,\n    have hx := sgf z,\n    cases hx with x gfxz,\n    use f x,\n    exact gfxz, done", "proof_hint": "sorry", "textAfter": "\nend\n\n", "height": 5, "editorText": "sorry", "lineOffset": 18, "name": "composition_surjective", "statement": "(X Y Z : set \u211d) (f : X \u2192 Y) (g : Y \u2192 Z) : surjective (g \u2218 f) \u2192 surjective g"}], "url": ""}, {"name": "", "problemIndex": 3, "objects": [{"type": "lean", "content": "415", "hidden": false}, {"type": "text", "content": "416"}, {"type": "lean", "content": "417", "hidden": false}, {"type": "lemma", "text": "418", "lean": "lemma square_continuous_at_3 : continuous_at_x square_f (3:\u211d) :=\n", "sideBar": true, "firstProofLineNumber": 24, "lastProofLineNumber": 69, "textBefore": "import data.real.basic\nopen function\nopen real\n\n/-\nClassic eps-delta definition of continuity.\nUse it to prove continuity at one point for a simple function.\nTo be proved equivalent to topological definition in topology world.\n\nWork in progress.\n-/\n\nnotation `|` x `|` := abs x\n\ndef continuous_at_x (f : \u211d \u2192 \u211d) (x : \u211d) := \n    \u2200 \u03b5 : \u211d, 0 < \u03b5 \u2192 \u2203 \u03b4 : \u211d, 0 < \u03b4 \u2227 \u2200 y : \u211d, |x - y| < \u03b4 \u2192 |f x - f y| < \u03b5\ndef square_f (x : \u211d) := x^2\n\n/- Lemma\nThe function $f(x) = x^2$ is continuous at $x=3$.\n-/\nlemma square_continuous_at_3 : continuous_at_x square_f (3:\u211d) :=\nbegin\n", "proof": "    intros \u03b5 h\u03b5,\n    set d := min (1:\u211d) (\u03b5/7) with hdefd,\n    use d,\n    split,\n    { -- prove this d is positive\n        have h1 : 0 < (1:\u211d), linarith,\n        have h2 : 0 < (\u03b5/7), linarith,\n        simp, split, exact h1, exact h2, \n    },\n    intros y hy,\n    unfold square_f,\n    have H : 3^2 - y^2 = (3-y)*(3+y), ring,\n    have G : | 3^2 - y^2 | = | (3-y)*(3+y) |, rw H,\n    have F : | (3-y)*(3+y) | = |3-y| * |3+y|, exact abs_mul _ _,\n    rw F at G, rw G,\n    have h1 := abs_lt.1 hy,\n    cases h1 with h11 h12,\n    have h1y : y < 3 + d, linarith,\n    have h2y : 3 - d < y, linarith,\n    have hdd : d \u2264 1, exact min_le_left (1:\u211d) (\u03b5/7),\n    have h3y : y < 4, linarith,\n    have h4y : 2 < y, linarith,\n    have h44 : 0 < |3+y|, \n        have h45 : 0 < 3 + y, linarith, \n        have h46 := abs_of_pos h45,\n        rw \u2190 h46 at h45, exact h45,\n    have h5y :=  (mul_lt_mul_right h44).mpr hy,\n    have h6y : 3+y < 7, linarith, \n    have h7y : |3+y| < 7, \n        have h45 : 0 < 3 + y, linarith, --reusing, should only do once\n        have h46 := abs_of_pos h45,\n        rw \u2190 h46 at h6y, exact h6y,\n    -- I shouldn't need to prove this twice, how to fix?\n    have hd : 0 < d,\n    { -- prove this d is positive\n        have h1 : 0 < (1:\u211d), linarith,\n        have h2 : 0 < (\u03b5/7), linarith,\n        simp, split, exact h1, exact h2, \n    },\n    have D := (mul_lt_mul_right hd).mpr h7y,\n    rw mul_comm at D, rw mul_comm 7 d at D,\n    have h9y : |3 - y| * |3 + y| <  d * 7, linarith,\n    have h10y : d \u2264 (\u03b5/7), exact min_le_right (1:\u211d) (\u03b5/7),\n    have h11y : |3 - y| * |3 + y| < (\u03b5/7) * 7, linarith,\n    have h12y : (\u03b5/7) * 7 = \u03b5, linarith,\n    rw h12y at h11y, exact h11y,", "proof_hint": "sorry", "textAfter": "\nend\n\n", "height": 46, "editorText": "sorry", "lineOffset": 23, "name": "square_continuous_at_3", "statement": "continuous_at_x square_f (3:\u211d)"}], "url": ""}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "419", "hidden": false}, {"type": "lean", "content": "420", "hidden": true}, {"type": "lean", "content": "421", "hidden": false}, {"type": "text", "content": "422"}, {"type": "lean", "content": "423", "hidden": false}, {"type": "lemma", "text": "424", "lean": "lemma cont_iff_seq_cont (f : \u211d \u2192 \u211d) : \n    \u2200 x : \u211d, continuous_at_x f x \u2194 seq_continuous_at_x f x :=\n", "sideBar": true, "firstProofLineNumber": 30, "lastProofLineNumber": 108, "textBefore": "import data.real.basic\n\nnamespace xena -- hide\n\nopen function\nopen real\n\nopen_locale classical\n\n/-\nClassic eps-delta definition of continuity is equivalent to \nthe definition using sequences.\n-/\n\nnotation `|` x `|` := abs x\ndef is_limit (a : \u2115 \u2192 \u211d) (l : \u211d) := \n    \u2200 \u03b5 : \u211d, 0 < \u03b5 \u2192 \u2203 N : \u2115, \u2200 n : \u2115, N \u2264 n \u2192 |a n - l| < \u03b5\n\ndef continuous_at_x (f : \u211d \u2192 \u211d) (x : \u211d) := \n    \u2200 \u03b5 : \u211d, 0 < \u03b5 \u2192 \u2203 \u03b4 : \u211d, 0 < \u03b4 \u2227 \u2200 y : \u211d, |y - x| < \u03b4 \u2192 |f y - f x| < \u03b5\ndef seq_continuous_at_x (f : \u211d \u2192 \u211d) (x : \u211d) :=\n    \u2200 (a : \u2115 \u2192 \u211d), is_limit a x \u2192 is_limit ( \u03bb n : \u2115, f (a n) ) (f x)\n\n/- Lemma\nThe two definitions of continuity are equivalent.\n-/\nlemma cont_iff_seq_cont (f : \u211d \u2192 \u211d) : \n    \u2200 x : \u211d, continuous_at_x f x \u2194 seq_continuous_at_x f x :=\nbegin\n", "proof": "    intro x,\n    split,\n    { -- classical continuity def -> sequence def\n        intros H a hax e he,\n        have h1 := H e he,\n        cases h1 with d hdd,\n        cases hdd with hd hy,\n        have h2 := hax d hd,\n        cases h2 with N hN,\n        use N,\n        intros n hn,\n        have hnd := hN n hn,\n        have G := hy (a n) hnd, exact G,\n    },\n    { -- sequence def -> classical def is a little trickier\n      -- contrapositive\n      contrapose!,\n      intro H, unfold continuous_at_x at H,\n      push_neg at H,\n      cases H with e hee,\n      cases hee with he hdd,\n      unfold seq_continuous_at_x, push_neg,\n      -- using these hypotheses, choose a sequence \n      have k : \u2200 n : \u2115, \u2203 y : \u211d, |y - x| < (1:\u211d)/(n+1) \u2227 e \u2264 | f y - f x|, \n        intro n,\n        have g1 := hdd ( (1:\u211d)/(n+1) ),\n        cases g1 with g11 g12,\n        exfalso,\n        {  -- this seems complicated, but other ways got into coercion problems\n            have f1 : \u2200 m : \u2115, 0 < m+1,\n                intro m, exact nat.succ_pos m,\n            have f2 : \u2200 m : \u2115, 0 < ( (m+1): \u211d),\n                intro m, \n                have f21 := f1 m,\n                norm_cast, linarith,\n            have f3 : \u2200 m : \u2115, 0 < 1 / ( (m+1): \u211d),\n                intro m,\n                have f31 := one_div_pos_of_pos (f2 m),\n                exact f31,\n            have f4 := f3 n,\n            linarith, \n        },\n        exact g12,\n      choose a ha using k,\n      use a,\n      -- prove this sequence does converge to x\n      split,\n      {\n        intros \u03b5 h\u03b5,\n        set N := nat_ceil ( (1:\u211d)/ \u03b5 ) with hN,\n        use N,\n        intros n hn,\n        have H := ha n, \n        cases H with h1 h2,\n        have hN1 := le_nat_ceil ( (1:\u211d)/\u03b5), rw \u2190 hN at hN1,\n        have hN2 : ((1:\u211d) / \u2191N) \u2264 \u03b5, \n            exact one_div_le_of_one_div_le_of_pos h\u03b5 hN1,\n        have hN3 : ((1:\u211d)/(\u2191n+1)) < ((1:\u211d) / \u2191N), \n            have hN31 : (n + 1) > N, linarith,\n            have hN32 : 0 < (n+1), linarith,\n            have hN33 : 0 < N, \n                have hN34 : 0 < ( (1:\u211d)/\u03b5 ), exact one_div_pos_of_pos h\u03b5,\n                have hN35 := lt_of_lt_of_le hN34 hN1,\n                norm_cast at hN35, exact hN35,\n            apply one_div_lt_one_div_of_lt,\n            norm_cast, linarith, norm_cast, linarith,\n        have hN4 : ((1:\u211d)/(\u2191n+1)) < \u03b5, linarith, \n        linarith,\n      },\n      \n      { -- but f(a n) does not converge to f(x)\n        unfold is_limit, push_neg,\n        use e, split, exact he, \n        intro N, use N, split, linarith,\n        have G := ha N, cases G with G1 G2, exact G2, \n      }, \n      done\n    },\n    done", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena -- hide\n", "height": 79, "editorText": "sorry", "lineOffset": 29, "name": "cont_iff_seq_cont", "statement": "(f : \u211d \u2192 \u211d) : \n    \u2200 x : \u211d, continuous_at_x f x \u2194 seq_continuous_at_x f x"}, {"type": "lean", "content": "425", "hidden": true}], "url": ""}], "parents": [4]}, {"name": "426", "levels": [{"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "427", "hidden": false}, {"type": "lean", "content": "428", "hidden": true}, {"type": "text", "content": "429"}, {"type": "lean", "content": "430", "hidden": true}, {"type": "lemma", "text": "431", "lean": "theorem union_finite (X Y : set \u211d) : finite X \u2192 finite Y \u2192 finite (X \u222a Y)  :=\n", "sideBar": true, "firstProofLineNumber": 26, "lastProofLineNumber": 26, "textBefore": "import data.real.basic\nimport topology.basic\nopen function\nopen set\n\nnamespace xena -- hide\n\n/-\n# Chapter 7 : Cardinality\n\n## Level 1\n\nA classical result about finite sets.\n-/\n\n-- begin hide\nlocal attribute [instance] classical.prop_decidable\n-- end hide\n\n/- Lemma\nIf $f : X \\to Y$ is an injective function and $Y$ is finite, then\n$X$ is also finite.\n-/\ntheorem union_finite (X Y : set \u211d) : finite X \u2192 finite Y \u2192 finite (X \u222a Y)  :=\nbegin\n", "proof": "    sorry,", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena -- hide\n", "height": 1, "editorText": "sorry", "lineOffset": 25, "name": "union_finite", "statement": "(X Y : set \u211d) : finite X \u2192 finite Y \u2192 finite (X \u222a Y)"}, {"type": "lean", "content": "432", "hidden": true}], "url": ""}, {"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "433", "hidden": false}, {"type": "lean", "content": "434", "hidden": true}, {"type": "text", "content": "435"}, {"type": "lean", "content": "436", "hidden": true}, {"type": "lemma", "text": "437", "lean": "theorem finite_inj (X Y : set \u211d) (f : X \u2192 Y) (hY : finite Y) : \n    injective f \u2192 finite X :=\n", "sideBar": true, "firstProofLineNumber": 26, "lastProofLineNumber": 29, "textBefore": "import data.real.basic\nimport topology.basic\nopen function\nopen set\n\nnamespace xena -- hide\n/-\n# Chapter 7 : Cardinality\n\n## Level 2\n\nA classical result about finite sets.\n-/\n\n-- begin hide\nlocal attribute [instance] classical.prop_decidable\n-- end hide\n\n/- Lemma\nIf $f : X \\to Y$ is an injective function and $Y$ is finite, then\n$X$ is also finite.\n-/\ntheorem finite_inj (X Y : set \u211d) (f : X \u2192 Y) (hY : finite Y) : \n    injective f \u2192 finite X :=\nbegin\n", "proof": "    intro hf,\n    have h1 := finite.fintype hY, -- can't get f(X) \u2286 Y, type coercion problem\n    --have H1 := card_image_of_injective,\n    sorry,", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena -- hide\n\n-- begin hide\n--#check finite_subsets_of_finite\n-- end hide\n", "height": 4, "editorText": "sorry", "lineOffset": 25, "name": "finite_inj", "statement": "(X Y : set \u211d) (f : X \u2192 Y) (hY : finite Y) : \n    injective f \u2192 finite X"}, {"type": "lean", "content": "438", "hidden": true}, {"type": "lean", "content": "439", "hidden": true}], "url": ""}, {"name": "", "problemIndex": 3, "objects": [{"type": "lean", "content": "440", "hidden": false}, {"type": "lean", "content": "441", "hidden": true}, {"type": "text", "content": "442"}, {"type": "lemma", "text": "443", "lean": "theorem countable_inj (X Y : set \u211d) (f : X \u2192 Y) (hY : countable Y) : \n    injective f \u2192 countable X :=\n", "sideBar": true, "firstProofLineNumber": 23, "lastProofLineNumber": 27, "textBefore": "import data.real.basic\nimport topology.basic\nopen function\nopen set\n\nnamespace xena -- hide\n\n/-\n# Chapter 7 : Cardinality\n\n## Level 3\n\nA classical result about countable sets.\n-/\n\n/- Lemma\nIf $f : X \\to Y$ is an injective function and $Y$ is countable, then\n$X$ is also countable.\n-/\ntheorem countable_inj (X Y : set \u211d) (f : X \u2192 Y) (hY : countable Y) : \n    injective f \u2192 countable X :=\nbegin\n", "proof": "   intro hf,\n    have H := countable_iff_exists_injective.1 hY,\n    cases H with g hg,\n    have G := countable_iff_exists_injective.2 \u27e8g \u2218 f, injective.comp hg hf\u27e9,\n    exact G, done", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena -- hide\n\n-- begin hide\n-- term mode proof due to Kenny Lau\ntheorem countable_inj_2 (X Y : set \u211d) (f : X \u2192 Y) (hY : countable Y) :\n    injective f \u2192 countable X :=\n\u03bb hf, let \u27e8g, hg\u27e9 := countable_iff_exists_injective.1 hY in\ncountable_iff_exists_injective.2 \u27e8g \u2218 f, injective.comp hg hf\u27e9\n-- end hide\n", "height": 5, "editorText": "sorry", "lineOffset": 22, "name": "countable_inj", "statement": "(X Y : set \u211d) (f : X \u2192 Y) (hY : countable Y) : \n    injective f \u2192 countable X"}, {"type": "lean", "content": "444", "hidden": true}, {"type": "lean", "content": "445", "hidden": true}], "url": ""}], "parents": [5]}, {"name": "446", "levels": [{"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "447", "hidden": false}, {"type": "lean", "content": "448", "hidden": true}, {"type": "text", "content": "449"}, {"type": "lean", "content": "450", "hidden": true}, {"type": "lemma", "text": "451", "lean": "theorem subset_union_left (A B : set X) : A \u2286 A \u222a B :=\n", "sideBar": true, "firstProofLineNumber": 31, "lastProofLineNumber": 33, "textBefore": "import data.real.basic\nimport data.vector\nopen real\n\nvariable X : Type -- hide\n\n/- \n# Work in progress.\n\n-/\n\n-- begin hide\n\n--#check finset\n--#check finset.card_range\n--#check list\n--Do we want a list? A vector? \n--either way, not sure how to go about this yet\n--def partition (a b : \u211d) (A: set.Icc a b) (n : \u2115) := list \u211d\n\n-- end hide\n\n\n\n/- Lemma\nIf $A$ and $B$ are sets of any type $X$, then\n$$ A \\subseteq A\\cup B.$$ \n-/\ntheorem subset_union_left (A B : set X) : A \u2286 A \u222a B :=\nbegin\n", "proof": "    --change \u2200 (x : \u03b1), x \u2208 A \u2192 x \u2208 A \u222a B,  --they may want to do this\n    intros x hx,\n    left, exact hx, done", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 3, "editorText": "sorry", "lineOffset": 30, "name": "subset_union_left", "statement": "(A B : set X) : A \u2286 A \u222a B"}], "url": ""}], "parents": [6]}, {"name": "452", "levels": [{"name": "", "problemIndex": 2, "objects": [{"type": "lean", "content": "453", "hidden": false}, {"type": "lean", "content": "454", "hidden": true}, {"type": "lemma", "text": "455", "lean": "lemma is_open_union_of_open (X : \u03b2 \u2192 set \u211d ) ( hj : \u2200 j, is_open (X j) )\n    : is_open (Union X) :=\n", "sideBar": true, "firstProofLineNumber": 28, "lastProofLineNumber": 39, "textBefore": "import data.real.basic\nimport data.set.lattice\n\nopen set\n\n--begin hide\nnamespace xena\n-- This will eventually be the first level, containing basic definitions\n-- Work in progress\n-- First I used \u2282 in the definition, then changed to \u2286 \n-- in order to be able to use subset.trans -- DS\n-- end hide\n\ndef is_open (X : set \u211d) := \u2200 x \u2208 X, \u2203 \u03b4 > 0, { y : \u211d  | x - \u03b4 < y \u2227 y < x + \u03b4 } \u2286 X\nvariable \u03b2 : Type\n\n-- begin hide\n-- Checking definitions\n--def countable_union (X : nat \u2192 set \u211d) := {t : \u211d | exists i, t \u2208 X i}\n-- end hide\n\n/- Lemma\nArbitrary union of open sets is open -- WIP, to do.\n-/\nlemma is_open_union_of_open (X : \u03b2 \u2192 set \u211d ) ( hj : \u2200 j, is_open (X j) )\n    : is_open (Union X) :=\nbegin\n", "proof": "    intros x hx,\n    simp at hx,\n    cases hx with i hi,\n    have H := hj i,\n    have G := H x hi,\n    cases G with d hd, use d,\n    cases hd with hd1 hd2,\n    split, exact hd1,\n    have hd3 : X i \u2286 Union X, \n        intros t ht, simp,\n        use i, exact ht,\n    exact subset.trans hd2 hd3, done", "proof_hint": "sorry", "textAfter": "\nend\n\n\nend xena -- hide", "height": 12, "editorText": "sorry", "lineOffset": 27, "name": "is_open_union_of_open", "statement": "(X : \u03b2 \u2192 set \u211d ) ( hj : \u2200 j, is_open (X j) )\n    : is_open (Union X)"}, {"type": "lean", "content": "456", "hidden": true}], "url": ""}, {"name": "", "problemIndex": 2, "objects": [{"type": "lean", "content": "457", "hidden": false}, {"type": "lean", "content": "458", "hidden": true}, {"type": "lemma", "text": "459", "lean": "lemma is_open_fin_inter_of_open (X : \u03b2 \u2192 set \u211d ) ( hj : \u2200 j, is_open (X j) )\n    : is_open (Inter X) :=\n", "sideBar": true, "firstProofLineNumber": 26, "lastProofLineNumber": 26, "textBefore": "import data.real.basic\nimport data.set.lattice\nimport topology.basic\nimport game.topology.union_open_sets\n\nopen set\n\n--begin hide\nnamespace xena\n-- Work in progress\n-- end hide\n\n\n-- begin hide\n-- Checking mathlib definitions\nvariable \u03b2 : Type*  \nvariable [fintype \u03b2]\n-- end hide\n\n/- Lemma\nFinite intersection of open sets is open -- WIP, to do.\n-/\nlemma is_open_fin_inter_of_open (X : \u03b2 \u2192 set \u211d ) ( hj : \u2200 j, is_open (X j) )\n    : is_open (Inter X) :=\nbegin\n", "proof": "    sorry,", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena -- hide\n", "height": 1, "editorText": "sorry", "lineOffset": 25, "name": "is_open_fin_inter_of_open", "statement": "(X : \u03b2 \u2192 set \u211d ) ( hj : \u2200 j, is_open (X j) )\n    : is_open (Inter X)"}, {"type": "lean", "content": "460", "hidden": true}], "url": ""}, {"name": "", "problemIndex": 2, "objects": [{"type": "lean", "content": "461", "hidden": false}, {"type": "lean", "content": "462", "hidden": true}, {"type": "lemma", "text": "463", "lean": "lemma is_closed_fin_union_of_closed (X : \u03b2 \u2192 set \u211d ) ( hj : \u2200 j, is_closed (X j) )\n    : is_closed (Union X) :=\n", "sideBar": true, "firstProofLineNumber": 26, "lastProofLineNumber": 26, "textBefore": "import data.real.basic\nimport data.set.lattice\nimport topology.basic\nimport game.topology.union_open_sets\n\nopen set\n\n--begin hide\nnamespace xena\n-- end hide\n\ndef is_closed (X : set \u211d) := is_open {x : \u211d | x \u2209 X }\n\n-- begin hide\n-- Checking mathlib definitions\nvariable \u03b2 : Type*  -- finite unions only\nvariable [fintype \u03b2]\n-- end hide\n\n/- Lemma\nFinite union of closed sets is closed -- WIP, to do.\n-/\nlemma is_closed_fin_union_of_closed (X : \u03b2 \u2192 set \u211d ) ( hj : \u2200 j, is_closed (X j) )\n    : is_closed (Union X) :=\nbegin\n", "proof": "    sorry,", "proof_hint": "sorry", "textAfter": "\nend\n\n\nend xena -- hide", "height": 1, "editorText": "sorry", "lineOffset": 25, "name": "is_closed_fin_union_of_closed", "statement": "(X : \u03b2 \u2192 set \u211d ) ( hj : \u2200 j, is_closed (X j) )\n    : is_closed (Union X)"}, {"type": "lean", "content": "464", "hidden": true}], "url": ""}, {"name": "", "problemIndex": 2, "objects": [{"type": "lean", "content": "465", "hidden": false}, {"type": "lean", "content": "466", "hidden": true}, {"type": "lemma", "text": "467", "lean": "lemma is_closed_inter_of_closed (X : \u03b2 \u2192 set \u211d ) ( hj : \u2200 j, is_closed (X j) )\n    : is_closed (Inter X) :=\n", "sideBar": true, "firstProofLineNumber": 25, "lastProofLineNumber": 25, "textBefore": "import data.real.basic\nimport data.set.lattice\nimport topology.basic\nimport game.topology.union_closed_sets\n\nopen set\n\n--begin hide\nnamespace xena\n-- Work in progress\n-- end hide\n\n\n-- begin hide\n-- Checking mathlib definitions\nvariable \u03b2 : Type*\n-- end hide\n\n/- Lemma\nArbitrary intersection of closed sets is closed -- WIP, to do.\n-/\nlemma is_closed_inter_of_closed (X : \u03b2 \u2192 set \u211d ) ( hj : \u2200 j, is_closed (X j) )\n    : is_closed (Inter X) :=\nbegin\n", "proof": "    sorry,", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena -- hide\n", "height": 1, "editorText": "sorry", "lineOffset": 24, "name": "is_closed_inter_of_closed", "statement": "(X : \u03b2 \u2192 set \u211d ) ( hj : \u2200 j, is_closed (X j) )\n    : is_closed (Inter X)"}, {"type": "lean", "content": "468", "hidden": true}], "url": ""}, {"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "469", "hidden": false}, {"type": "text", "content": "470"}, {"type": "lean", "content": "471", "hidden": false}, {"type": "lean", "content": "472", "hidden": true}, {"type": "lemma", "text": "473", "lean": "lemma hausdorff_reals (a b : \u211d) (hne : a \u2260 b) : \n  \u2203 (\u03b5:\u211d), \u03b5 > 0 \u2227 (neighborhood a \u03b5 \u2229 neighborhood b \u03b5 = \u2205) :=\n", "sideBar": true, "firstProofLineNumber": 24, "lastProofLineNumber": 54, "textBefore": "import data.real.basic\n\n--begin hide\nnamespace xena\ndef neighborhood1 (a : \u211d) (\u03b5 : \u211d) (h : \u03b5 > 0) := { x : \u211d | abs(a - x) < \u03b5}\n\n/-\n To be technically correct, the definition below should include \n the hypothesis that \u03b5 > 0, see the one above.\n But that does raise some issues which I don't know how to handle\n when using it in the main result lemma.\n-/\n-- end hide\n\ndef neighborhood (a : \u211d) (\u03b5 : \u211d) := { x : \u211d | abs(a - x) < \u03b5} \nlocal attribute [instance] classical.prop_decidable --hide\n\n/- Lemma\nHausdorff property for the reals.\n-/\nlemma hausdorff_reals (a b : \u211d) (hne : a \u2260 b) : \n  \u2203 (\u03b5:\u211d), \u03b5 > 0 \u2227 (neighborhood a \u03b5 \u2229 neighborhood b \u03b5 = \u2205) :=\nbegin\n", "proof": "  set d := abs(b-a) with hd,\n  have h1 : 0 < d, \n    rw hd, by_contradiction hf, push_neg at hf, \n    have h11 := abs_nonneg (b-a),\n    have h12 : abs(b-a) = 0, linarith,\n    have h13 : (b-a) = 0, exact abs_eq_zero.1 h12,\n    have h14 : a = b, linarith, \n    exact hne h14,\n  set e := d / 3 with he,\n  use e, split, linarith,\n  by_contradiction H,\n  -- the stuff below can probably be made much shorter\n  have G := set.ne_empty_iff_nonempty.mp H,\n  cases G with x hab, cases hab with ha hb,\n  have ha1 : abs(a-x) < e, exact ha,  -- linarith below won't work\n  have hb1 : abs(b-x) < e, exact hb,  -- without these\n  have hb2 : abs(b-x) = abs(x-b), exact abs_sub _ _,\n  rw hb2 at hb1,\n  have hab := abs_add (a-x) (x-b), \n  have hab1 : a - x + (x - b) = a - b, ring,\n  rw hab1 at hab,\n  have hab2 : abs(a-b) <  e + e, linarith,\n  have hdd : d = 3 * e, rw he, linarith,\n  rw hdd at hd, \n  have hde := eq.symm hd, \n  have hdf : abs(b-a) > 2 * e,\n    linarith,\n  have hdg : e + e = 2 * e, linarith,\n  rw hdg at hab2, \n  have hb2 : abs(b-a) = abs(a-b), exact abs_sub _ _,\n  rw hb2 at hdf, linarith, done", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena -- hide\n", "height": 31, "editorText": "sorry", "lineOffset": 23, "name": "hausdorff_reals", "statement": "(a b : \u211d) (hne : a \u2260 b) : \n  \u2203 (\u03b5:\u211d), \u03b5 > 0 \u2227 (neighborhood a \u03b5 \u2229 neighborhood b \u03b5 = \u2205)"}, {"type": "lean", "content": "474", "hidden": true}], "url": ""}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "475", "hidden": false}, {"type": "lean", "content": "476", "hidden": true}, {"type": "lean", "content": "477", "hidden": false}, {"type": "text", "content": "478"}, {"type": "lean", "content": "479", "hidden": false}, {"type": "text", "content": "480"}, {"type": "lemma", "text": "481", "lean": "lemma continuity_topological (f : \u211d \u2192 \u211d) (X : set \u211d) :\n    continuous_on_set f X \u2194 continuous_on_topo_def f X :=\n", "sideBar": true, "firstProofLineNumber": 44, "lastProofLineNumber": 44, "textBefore": "import data.real.basic\nimport topology.basic\n\nnamespace xena -- hide\n\nopen function\nopen real\nopen set\n\n/-\nClassic eps-delta definition of continuity equivalent to topological definition.\n\nWork in progress.\n-/\n\nnotation `|` x `|` := abs x\n\ndef continuous_at_x (f : \u211d \u2192 \u211d) (x : \u211d) := \n    \u2200 \u03b5 : \u211d, 0 < \u03b5 \u2192 \u2203 \u03b4 : \u211d, 0 < \u03b4 \u2227 \u2200 y : \u211d, |x - y| < \u03b4 \u2192 |f x - f y| < \u03b5\ndef continuous_on_set (f : \u211d \u2192 \u211d) (X : set \u211d) :=\n    \u2200 x \u2208 X, continuous_at_x f x\ndef open_in_R (Y : set \u211d) := \u2200 x \u2208 Y, \u2203 \u03b5 : \u211d, 0 < \u03b5 \u2227 { y | |x-y| < \u03b5 } \u2282 Y\ndef open_in_X (S : set \u211d) (X : set \u211d) (hS : S \u2282 X) := \u2203 Y : set \u211d, \n    S = Y \u2229 X \u2227 open_in_R Y \ndef preimage_in_X (f : \u211d \u2192 \u211d) (X : set \u211d) (T : set \u211d) :=\n    { x | x \u2208 X \u2227 \u2203 t \u2208 T, f x = t}\ndef continuous_on_topo_def (f : \u211d \u2192 \u211d) (X : set \u211d) :=\n    \u2200 T : set \u211d, open_in_R T \u2192 open_in_R (preimage_in_X f X T)\n\n\n/-\ntheorem continuous_on_topo_def2 (f : \u211d \u2192 \u211d) (X : set \u211d) :\n  \u2200 x \u2208 X, \u2200 t : set \u211d, is_open t \u2192 f x \u2208 t \u2192 \u2203 u, is_open u \u2227 x \u2208 u \u2227\n    u \u2229 X \u2286 f \u207b\u00b9' t :=\n-/\n\n\n/- Lemma\nEquivalent definitions of continuity.\n-/\nlemma continuity_topological (f : \u211d \u2192 \u211d) (X : set \u211d) :\n    continuous_on_set f X \u2194 continuous_on_topo_def f X :=\nbegin\n", "proof": "    sorry,", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena\n\n\n", "height": 1, "editorText": "sorry", "lineOffset": 43, "name": "continuity_topological", "statement": "(f : \u211d \u2192 \u211d) (X : set \u211d) :\n    continuous_on_set f X \u2194 continuous_on_topo_def f X"}, {"type": "lean", "content": "482", "hidden": false}], "url": ""}], "parents": [7]}, {"name": "483", "levels": [{"name": "", "problemIndex": 22, "objects": [{"type": "lean", "content": "484", "hidden": true}, {"type": "lean", "content": "485", "hidden": false}, {"type": "text", "content": "486"}, {"type": "lean", "content": "487", "hidden": false}, {"type": "text", "content": "488"}, {"type": "lean", "content": "489", "hidden": false}, {"type": "lean", "content": "490", "hidden": true}, {"type": "lean", "content": "491", "hidden": false}, {"type": "text", "content": "492"}, {"type": "axiom", "content": "493", "name": "le_refl a : a \u2264 a", "sideBar": true}, {"type": "axiom", "content": "494", "name": "le_trans : a \u2264 b \u2192 b \u2264 c \u2192 a \u2264 c", "sideBar": true}, {"type": "axiom", "content": "495", "name": "le_antisymm : a \u2264 b \u2192 b \u2264 a \u2192 a = b", "sideBar": true}, {"type": "axiom", "content": "496", "name": "le_total a b : a \u2264 b \u2228 b \u2264 a", "sideBar": true}, {"type": "axiom", "content": "497", "name": "lt_iff_le_and_ne : a < b \u2194 a \u2264 b \u2227 a \u2260 b", "sideBar": true}, {"type": "axiom", "content": "498", "name": "lt_of_le_of_lt : a \u2264 b \u2192 b < c \u2192 a < c", "sideBar": true}, {"type": "axiom", "content": "499", "name": "lt_of_lt_of_le : a < b \u2192 b \u2264 c \u2192 a < c", "sideBar": true}, {"type": "text", "content": "500"}, {"type": "axiom", "content": "501", "name": "max_eq_right : a \u2264 b \u2192 max a b = b", "sideBar": true}, {"type": "axiom", "content": "502", "name": "max_eq_left : b \u2264 a \u2192 max a b = a", "sideBar": true}, {"type": "lean", "content": "503", "hidden": true}, {"type": "text", "content": "504"}, {"type": "hint", "content": "505", "title": "506"}, {"type": "lemma", "text": "507", "lean": "theorem max_choice (a b : \u211d) : max a b = a \u2228 max a b = b :=\n", "sideBar": true, "firstProofLineNumber": 121, "lastProofLineNumber": 130, "textBefore": "import tactic -- hide\n\nimport data.real.basic -- imports the real numbers\n/-\n\n-/\nopen_locale classical -- allow proofs by contradiction\n/-\n\n-/\nnoncomputable theory -- don't fuss about the reals being noncomputable\n\nnamespace xena -- hide\n\n-- Let a, b, c be real numbers\nvariables {a b c : \u211d}\n\n/-\n# Chapter ? : Max and abs\n\n## Level 1\n\nIn this chapter we develop a basic interface for the `max a b` and `abs a`\nfunction on the real numbers. Before we start, you will need to know\nthe basic API for `\u2264` and `<`, which looks like this:\n\n```\nexample : a \u2264 a := le_refl a\n\nexample : a \u2264 b \u2192 b \u2264 c \u2192 a \u2264 c := le_trans\n\nexample : a \u2264 b \u2192 b \u2264 a \u2192 a = b := le_antisymm\n\nexample : a \u2264 b \u2228 b \u2264 a := le_total a b\n\nexample : a < b \u2194 a \u2264 b \u2227 a \u2260 b := lt_iff_le_and_ne\n\nexample : a \u2264 b \u2192 b < c \u2192 a < c := lt_of_le_of_lt\n\nexample : a < b \u2192 b \u2264 c \u2192 a < c := lt_of_lt_of_le\n```\n-/\n\n/- Axiom : le_refl a : a \u2264 a\n-/\n\n/- Axiom : le_trans : a \u2264 b \u2192 b \u2264 c \u2192 a \u2264 c\n-/\n\n/- Axiom : le_antisymm : a \u2264 b \u2192 b \u2264 a \u2192 a = b\n-/\n\n/- Axiom : le_total a b : a \u2264 b \u2228 b \u2264 a\n-/\n\n/- Axiom : lt_iff_le_and_ne : a < b \u2194 a \u2264 b \u2227 a \u2260 b\n-/\n\n/- Axiom : lt_of_le_of_lt : a \u2264 b \u2192 b < c \u2192 a < c \n-/\n\n/- Axiom : lt_of_lt_of_le : a < b \u2192 b \u2264 c \u2192 a < c\n-/\n\n/-\nWe start with `max a b := if a \u2264 b then b else a`. It is\nuniquely characterised by the following two properties, which are hence\nall you will need to know:\n\n```\ntheorem max_eq_right : a \u2264 b \u2192 max a b = b\n\ntheorem max_eq_left : b \u2264 a \u2192 max a b = a\n```\n-/\n\n/- Axiom : max_eq_right : a \u2264 b \u2192 max a b = b\n-/\n\n/- Axiom : max_eq_left : b \u2264 a \u2192 max a b = a\n-/\n\n-- begin hide\ndef max (a b : \u211d) := if a \u2264 b then b else a\n\n-- need if_pos to do this one\ntheorem max_eq_right (hab : a \u2264 b) : max a b = b :=\nbegin\n  unfold max,\n  rw if_pos hab,  \nend\n\n-- need if_neg to do this one\ntheorem max_eq_left (hba : b \u2264 a) : max a b = a :=\nbegin\n  by_cases hab : a \u2264 b,\n  { rw max_eq_right hab,\n    exact le_antisymm hba hab,\n  },\n  { unfold max,\n    rw if_neg hab,\n  }\nend\n-- end hide\n\n/-\nAll of these theorems are in the theorem statement box on the left.\nSee if you can now prove the useful `max_choice` lemma using them.\n-/\n\n/- Hint : Hint\nDo a case split with `cases le_total a b`. \n-/\n\n/- Lemma\nFor any two real numbers $a$ and $b$, either $\\max(a,b) = a$\nor $\\max(a,b) = b$.\n-/\ntheorem max_choice (a b : \u211d) : max a b = a \u2228 max a b = b :=\nbegin\n", "proof": "  cases le_total a b with hab hba,\n  { right,\n    exact max_eq_right hab\n  },\n  { left,\n    exact max_eq_left hba\n  }\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena --hide\n", "height": 10, "editorText": "sorry", "lineOffset": 120, "name": "max_choice", "statement": "(a b : \u211d) : max a b = a \u2228 max a b = b"}, {"type": "lean", "content": "508", "hidden": true}], "url": ""}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "509", "hidden": true}, {"type": "lean", "content": "510", "hidden": true}, {"type": "lean", "content": "511", "hidden": true}, {"type": "lean", "content": "512", "hidden": true}, {"type": "text", "content": "513"}, {"type": "hint", "content": "514", "title": "515"}, {"type": "lemma", "text": "516", "lean": "theorem max_comm (a b : \u211d) : max a b = max b a :=\n", "sideBar": true, "firstProofLineNumber": 26, "lastProofLineNumber": 35, "textBefore": "import game.max.level01 -- hide\n\nopen_locale classical -- hide\n\nnoncomputable theory -- hide\n\nnamespace xena -- hide\n\n/-\n# Chapter ? : Max and abs\n\n## Level 2\n\n`max_comm` is the statement that `max a b = max b a`. See if you can prove it.\n-/\n\n/- Hint : Hint\nAgain, do a case split with `cases le_total a b`. \n-/\n\n/- Lemma\nFor any real numbers $a$ and $b$, we have $\\max(a,b) = \\max(b,a).$\n-/\ntheorem max_comm (a b : \u211d) : max a b = max b a :=\nbegin\n", "proof": "  cases le_total a b with hab hba,\n  { rw max_eq_right hab,\n    rw max_eq_left hab,\n  },\n  { rw max_eq_left hba,\n    rw max_eq_right hba\n  }  \n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena --hide\n", "height": 10, "editorText": "sorry", "lineOffset": 25, "name": "max_comm", "statement": "(a b : \u211d) : max a b = max b a"}, {"type": "lean", "content": "517", "hidden": true}], "url": ""}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "518", "hidden": true}, {"type": "lean", "content": "519", "hidden": true}, {"type": "lean", "content": "520", "hidden": true}, {"type": "lean", "content": "521", "hidden": true}, {"type": "text", "content": "522"}, {"type": "lemma", "text": "523", "lean": "theorem le_max_left (a b : \u211d) : a \u2264 max a b :=\n", "sideBar": true, "firstProofLineNumber": 27, "lastProofLineNumber": 35, "textBefore": "import game.max.level02 -- hide\n\nopen_locale classical -- hide\n\nnoncomputable theory -- hide\n\nnamespace xena -- hide\n\n/-\n# Chapter ? : Max and abs\n\n## Level 3\n\n`le_max_left` is the statement that `a \u2264 max a b`.\n\nTechnical note: in contrast to the natural number game, the `rw` used\nin the real number game is Lean's more powerful `rw`, which automatically\ntries `refl` after a rewrite; note that `\u2264` is reflexive, so `refl` will\nclose a goal of the form `a \u2264 a`. \n-/\n\n/- Lemma\nFor any real numbers $a$ and $b$, we have $a\\leq\\max(a,b).$\n-/\ntheorem le_max_left (a b : \u211d) : a \u2264 max a b :=\nbegin\n", "proof": "  cases le_total a b with hab hba,\n  { rw max_eq_right hab,\n    assumption\n  },\n  { rw max_eq_left hba,\n    -- Lean closes a \u2264 a automatically because \u2264 is reflexive\n  }  \n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena --hide\n", "height": 9, "editorText": "sorry", "lineOffset": 26, "name": "le_max_left", "statement": "(a b : \u211d) : a \u2264 max a b"}, {"type": "lean", "content": "524", "hidden": true}], "url": ""}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "525", "hidden": true}, {"type": "lean", "content": "526", "hidden": true}, {"type": "lean", "content": "527", "hidden": true}, {"type": "lean", "content": "528", "hidden": true}, {"type": "text", "content": "529"}, {"type": "hint", "content": "530", "title": "531"}, {"type": "lemma", "text": "532", "lean": "theorem le_max_right (a b : \u211d) : b \u2264 max a b :=\n", "sideBar": true, "firstProofLineNumber": 28, "lastProofLineNumber": 31, "textBefore": "import game.max.level03 -- hide\n\nopen_locale classical -- hide\n\nnoncomputable theory -- hide\n\nnamespace xena -- hide\n\n/-\n# Chapter ? : Max and abs\n\n## Level 4\n\n`le_max_right` is the statement that `b \u2264 max a b`. There's a short\nproof using what we've already done.\n-/\n\n/- Hint : \nWhy not start with `rw max_comm`?\n-/\n\n/- Lemma\nFor any real numbers $a$ and $b$, we have $b\\leq\\max(a,b).$\n-/\n\ntheorem le_max_right (a b : \u211d) : b \u2264 max a b :=\nbegin\n", "proof": "  rw max_comm,\n  apply le_max_left\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena --hide\n", "height": 4, "editorText": "sorry", "lineOffset": 27, "name": "le_max_right", "statement": "(a b : \u211d) : b \u2264 max a b"}, {"type": "lean", "content": "533", "hidden": true}], "url": ""}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "534", "hidden": true}, {"type": "lean", "content": "535", "hidden": true}, {"type": "lean", "content": "536", "hidden": true}, {"type": "lean", "content": "537", "hidden": true}, {"type": "text", "content": "538"}, {"type": "lemma", "text": "539", "lean": "theorem max_le {a b c : \u211d} (hac : a \u2264 c) (hbc : b \u2264 c) : max a b \u2264 c :=\n", "sideBar": true, "firstProofLineNumber": 27, "lastProofLineNumber": 35, "textBefore": "import game.max.level04 -- hide\n\nopen_locale classical -- hide\n\nnoncomputable theory -- hide\n\nnamespace xena -- hide\n\n/-\n# Chapter ? : Max and abs\n\n## Level 5\n\n`max_le` is really useful; it says that if `a \u2264 c` and `b \u2264 c`\nthen `max a b \u2264 c`.\n\nNote that in the Lean formulation, the variables are *implicit*,\nmeaning that Lean will guess them.\n-/\n\n/- Lemma\nIf $a$, $b$, $c$ are real numbers with $a\\leq c$ and $b\\leq c$,\nthen $\\max(a,b)\\leq c.$\n-/\ntheorem max_le {a b c : \u211d} (hac : a \u2264 c) (hbc : b \u2264 c) : max a b \u2264 c :=\nbegin\n", "proof": "  cases max_choice a b with ha hb,\n  { rw ha,\n    assumption\n  },\n  { rw hb,\n    assumption\n  }\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena --hide\n", "height": 9, "editorText": "sorry", "lineOffset": 26, "name": "max_le", "statement": "{a b c : \u211d} (hac : a \u2264 c) (hbc : b \u2264 c) : max a b \u2264 c"}, {"type": "lean", "content": "540", "hidden": true}], "url": ""}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "541", "hidden": true}, {"type": "lean", "content": "542", "hidden": true}, {"type": "lean", "content": "543", "hidden": true}, {"type": "lean", "content": "544", "hidden": true}, {"type": "text", "content": "545"}, {"type": "hint", "content": "546", "title": "547"}, {"type": "lemma", "text": "548", "lean": "theorem max_le_iff {a b c : \u211d} : a \u2264 c \u2227 b \u2264 c \u2194 max a b \u2264 c :=\n", "sideBar": true, "firstProofLineNumber": 45, "lastProofLineNumber": 57, "textBefore": "import game.max.level05 -- hide\n\nopen_locale classical -- hide\n\nnoncomputable theory -- hide\n\nnamespace xena -- hide\n\n/-\n# Chapter ? : Max and abs\n\n## Level 6\n\nIn fact `max_le` can be beefed up to an iff statement.\n-/\n\n/- Hint : Tip : using `le_trans` \nIf your goal is `x \u2264 z` and you have a hypothesis `h : y \u2264 z`\nthen of course it will suffice to prove `x \u2264 y` and then you\ncan use transitivity. Instead of `have hxy : x \u2264 y,`, opening\na new goal and adding a new hypothesis to our list, you can\ndo \n\n```\napply le_trans _ h\n```\n\nor\n\n```\nrefine le_trans _ h\n```\n\nand this just reduces the goal to proving `x \u2264 y` immediately. \n\n-/\n\n/- Lemma\nIf $a$, $b$, $c$ are real numbers,\nthen ($a\\leq c$ and $b\\leq c$) iff $\\max(a,b)\\leq c.$\n-/\n\ntheorem max_le_iff {a b c : \u211d} : a \u2264 c \u2227 b \u2264 c \u2194 max a b \u2264 c :=\nbegin\n", "proof": "  split,\n  { intro h,\n    cases h with hac hbc,\n    exact max_le hac hbc\n  },\n  { intro habc,\n    split,\n    { apply le_trans _ habc,\n      apply le_max_left},\n    { apply le_trans _ habc,\n      apply le_max_right\n    }\n  }", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena --hide\n\n/- Hint : Solution\n  split,\n  { intro h,\n    cases h with hac hbc,\n    exact max_le hac hbc\n  },\n  { intro habc,\n    split,\n    { apply le_trans _ habc,\n      apply le_max_left},\n    { apply le_trans _ habc,\n      apply le_max_right\n    }\n  }\n-/\n", "height": 13, "editorText": "sorry", "lineOffset": 44, "name": "max_le_iff", "statement": "{a b c : \u211d} : a \u2264 c \u2227 b \u2264 c \u2194 max a b \u2264 c"}, {"type": "lean", "content": "549", "hidden": true}, {"type": "hint", "content": "550", "title": "551"}], "url": ""}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "552", "hidden": true}, {"type": "lean", "content": "553", "hidden": true}, {"type": "lean", "content": "554", "hidden": true}, {"type": "lean", "content": "555", "hidden": true}, {"type": "text", "content": "556"}, {"type": "lemma", "text": "557", "lean": "theorem max_lt {a b c : \u211d} (hac : a < c) (hbc : b < c) : max a b < c :=\n", "sideBar": true, "firstProofLineNumber": 24, "lastProofLineNumber": 33, "textBefore": "import game.max.level06 -- hide\n\nopen_locale classical -- hide\n\nnoncomputable theory -- hide\n\nnamespace xena -- hide\n\n/-\n# Chapter ? : Max and abs\n\n## Level 7\n\n`max_lt` and `max_lt_iff` are equally useful. Let's knock them off\nusing the same techniques.\n-/\n\n/- Lemma\nIf $a$, $b$, $c$ are real numbers with $a<c$ and $b<c$,\nthen $\\max(a,b)<c.$\n-/\ntheorem max_lt {a b c : \u211d} (hac : a < c) (hbc : b < c) : max a b < c :=\nbegin\n", "proof": "  cases max_choice a b with ha hb,\n  { rw ha,\n    assumption\n  },\n  { rw hb,\n    assumption\n  }\n\n\n  ", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena --hide\n", "height": 10, "editorText": "sorry", "lineOffset": 23, "name": "max_lt", "statement": "{a b c : \u211d} (hac : a < c) (hbc : b < c) : max a b < c"}, {"type": "lean", "content": "558", "hidden": true}], "url": ""}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "559", "hidden": true}, {"type": "lean", "content": "560", "hidden": true}, {"type": "lean", "content": "561", "hidden": true}, {"type": "lean", "content": "562", "hidden": true}, {"type": "text", "content": "563"}, {"type": "lemma", "text": "564", "lean": "theorem max_lt_iff {a b c : \u211d} : a < c \u2227 b < c \u2194 max a b < c :=\n", "sideBar": true, "firstProofLineNumber": 27, "lastProofLineNumber": 39, "textBefore": "import game.max.level07 -- hide\n\nopen_locale classical -- hide\n\nnoncomputable theory -- hide\n\nnamespace xena -- hide\n\n/-\n# Chapter ? : Max and abs\n\n## Level 8\n\nSee if you can do `max_lt_iff` without introducing\nany auxiliary hypotheses with `have`. Don't forget to\ncheck the list of theorems to see the interface for `\u2264`\nand `<`.\n-/\n\n/- Lemma\nIf $a$, $b$, $c$ are real numbers,\nthen ($a<c$ and $b<c$) iff $\\max(a,b)<c.$\n-/\n\ntheorem max_lt_iff {a b c : \u211d} : a < c \u2227 b < c \u2194 max a b < c :=\nbegin\n", "proof": "  split,\n  { intro h,\n    cases h with hac hbc,\n    exact max_lt hac hbc\n  },\n  { intro habc,\n    split,\n    { apply lt_of_le_of_lt _ habc,\n      apply le_max_left},\n    { apply lt_of_le_of_lt _ habc,\n      apply le_max_right\n    }\n  },", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena --hide\n", "height": 13, "editorText": "sorry", "lineOffset": 26, "name": "max_lt_iff", "statement": "{a b c : \u211d} : a < c \u2227 b < c \u2194 max a b < c"}, {"type": "lean", "content": "565", "hidden": true}], "url": ""}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "566", "hidden": true}, {"type": "lean", "content": "567", "hidden": true}, {"type": "lean", "content": "568", "hidden": true}, {"type": "lean", "content": "569", "hidden": true}, {"type": "text", "content": "570"}, {"type": "lemma", "text": "571", "lean": "theorem le_max_iff {a b c : \u211d} : a \u2264 max b c \u2194 a \u2264 b \u2228 a \u2264 c :=\n", "sideBar": true, "firstProofLineNumber": 24, "lastProofLineNumber": 42, "textBefore": "import game.max.level08 -- hide\n\nopen_locale classical -- hide\n\nnoncomputable theory -- hide\n\nnamespace xena -- hide\n\n/-\n# Chapter ? : Max\n\n## Level 9\n\nWe've done `max_le_iff`; here is `le_max_iff`. \n-/\n\n/- Lemma\nIf $a$, $b$, $c$ are real numbers,\nthen $a\\leq\\max(b,c)$ iff ($a\\leq b$ or $a\\leq c$).\n-/\n\ntheorem le_max_iff {a b c : \u211d} : a \u2264 max b c \u2194 a \u2264 b \u2228 a \u2264 c :=\nbegin\n", "proof": "  split,\n  { intro ha,\n    cases le_total b c with hbc hcb,\n    { rw max_eq_right hbc at ha,\n      right,\n      assumption,\n    },\n    { rw max_eq_left hcb at ha,\n      left,\n      assumption\n    }\n  },\n  { intro habc,\n    cases habc with hab hac,\n    { apply le_trans hab,\n      apply le_max_left},\n    { apply le_trans hac,\n      apply le_max_right},\n  }", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena --hide\n", "height": 19, "editorText": "sorry", "lineOffset": 23, "name": "le_max_iff", "statement": "{a b c : \u211d} : a \u2264 max b c \u2194 a \u2264 b \u2228 a \u2264 c"}, {"type": "lean", "content": "572", "hidden": true}], "url": ""}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "573", "hidden": true}, {"type": "lean", "content": "574", "hidden": true}, {"type": "lean", "content": "575", "hidden": true}, {"type": "lean", "content": "576", "hidden": true}, {"type": "text", "content": "577"}, {"type": "lemma", "text": "578", "lean": "theorem lt_max_iff {a b c : \u211d} : a < max b c \u2194 a < b \u2228 a < c :=\n", "sideBar": true, "firstProofLineNumber": 24, "lastProofLineNumber": 42, "textBefore": "import game.max.level09 -- hide\n\nopen_locale classical -- hide\n\nnoncomputable theory -- hide\n\nnamespace xena -- hide\n\n/-\n# Chapter ? : Max\n\n## Level 10\n\nAnd finally `lt_max_iff`. \n-/\n\n/- Lemma\nIf $a$, $b$, $c$ are real numbers,\nthen $a<\\max(b,c)$ iff ($a<b$ or $a<c$).\n-/\n\ntheorem lt_max_iff {a b c : \u211d} : a < max b c \u2194 a < b \u2228 a < c :=\nbegin\n", "proof": "  split,\n  { intro ha,\n    cases le_total b c with hbc hcb,\n    { rw max_eq_right hbc at ha,\n      right,\n      assumption,\n    },\n    { rw max_eq_left hcb at ha,\n      left,\n      assumption\n    }\n  },\n  { intro habc,\n    cases habc with hab hac,\n    { apply lt_of_lt_of_le hab,\n      apply le_max_left},\n    { apply lt_of_lt_of_le hac,\n      apply le_max_right},\n  }", "proof_hint": "sorry", "textAfter": "\nend\n\nend xena --hide\n", "height": 19, "editorText": "sorry", "lineOffset": 23, "name": "lt_max_iff", "statement": "{a b c : \u211d} : a < max b c \u2194 a < b \u2228 a < c"}, {"type": "lean", "content": "579", "hidden": true}], "url": ""}]}], "texts": [["Real number game", "# The Real Number Game, version 1.0beta\n\n## By Kevin Buzzard, Dan Stanescu and Gavin Thomson\n\n# What is this game?\n\nWelcome to the real number game -- a game to help undergraduates learn analysis through Lean,\na formal proof verification system. Starting from the real numbers with its usual structure,\nwe develop the theory of bounds, least upper bounds and greatest lower bounds (sups and infs),\ninfinite sequences and infinite series. We develop the theory through problem-solving,\ngetting students to formalise proofs in the theory.\n\nThis game is a sequel to\n<a href=\"http://wwwf.imperial.ac.uk/~buzzard/xena/natural_number_game/\" target=\"blank\">the natural number game</a>.\nThe levels in the Real Number Game need to be solved using tactics. To learn how to use these tactics, I would\nrecommend that you first play the Natural Number Game up to at least \"Advanced Proposition world\". I will\nnot go through a careful explanation of the tactics taught by the natural number game here.\n\nBlue nodes on the graph are ones that you are ready to enter. Grey nodes you should stay away\nfrom -- try blue ones higher up the chain first. Green nodes are completed.\n\n# Thanks\n\nMany thanks to Mohammad Pedramfar, without whom this game would not exist.\n\nSeveral people contributed ideas and sometimes full proofs, most of which have found \ntheir place in the game in one way or another.\nThis aims at being a complete list eventually: Kenny Lau, Patrick Massot, Christopher Sumnicht, Aniruddh Agarwal.\n\n# Questions?\n\nYou can ask questions on the <a href=\"https://leanprover.zulipchat.com/\" target=\"blank\">Lean Zulip chat</a>,\nwhere I am often to be found. \n\nThe Real Number Game is brought to you by the Xena project, a project based at Imperial College London\nwhose aim is to get mathematics undergraduates using computer theorem provers.\nLean is a computer theorem prover being developed at Microsoft Research.\n\nProve a theorem. Write a function. <a href=\"https://twitter.com/XenaProject\" target=\"blank\">@XenaProject</a>.\n", "Sets", "import data.set.basic -- hide\n", "import kb_defs -- hide\n", "namespace xena -- hide\n", "open_locale classical -- hide\n", "variable X : Type -- we will think of X as a set here\n", "# Chapter 1 : Sets\n\n## Level 1 : Introduction to sets.\n\nThis chapter assumes you are familiar with the following tactics:\n`rw`, `intro`, `apply`, `exact`, `cases`, `split`, `use`, `left`, `right` and `exfalso`.\n\n(TODO (kmb) : check this list is exhaustive)\n(We might need to add `ring`)\n\nIf you are not, try playing Function World and Proposition World of the Natural Number Game.\n\n## Sets in Lean\n\nIn this world, there will be an ambient \"big\" set `X` (actually `X` will be a type),\nand we will consider subsets of `X`. The type of subsets of `X` is called `set X`.\nSo if you see `A : set X` it means that `A` is a subset of `X`.\n\n## subsets (\u2286) and `subset_iff`\n\nIf `A B : set X` (i.e. `A` and `B` are subsets of `X`), then `A \u2286 B` is a\nProposition, i.e. a true/false statement. Lean knows the following fact:\n\n```\nsubset_iff : A \u2286 B \u2194 \u2200 x : X, x \u2208 A \u2192 x \u2208 B\n```\n\nLet's see if you can prove `A \u2286 A` by rewriting `subset_iff`.\n", "A \u2286 B \u2194 \u2200 x : X, x \u2208 A \u2192 x \u2208 B\n", "The `assumption` tactic will close a goal if it is equal to one of your\nhypotheses. It's actually longer to type than `exact hx`, but it's easier to\nuse because you don't have to bother remembering what you called `hx`.\n\n", "Tactic tip", "To make progress with a goal of form `\u2200 a : X, ...`, introduce a term of type `X` by using a familiar tactic. \n\nIn this example, using\n\n`intro a,`\n\nwill introduce an arbitrary term of type `X`.\n\nNote that this is the tactic we use to assume a hypothesis (when proving an implication), or to choose an arbitrary element of some domain (when defining a function).\n\nUse the same tactic to introduce an appropriately named hypothesis for an implication, and close the goal with the `exact` tactic.\n", "Stuck? Here's a hint.", "If you get stuck, you can click on the hints for more details!\n", "If $A$ is a set of elements of type X, then $A \\subseteq A$. \n", "end xena --hide\n", "import game.sets.sets_level01 -- hide\n", "namespace xena -- hide\n", "open_locale classical -- hide\n", "variable X : Type -- hide\n", "# Chapter 1 : Sets\n\n## Level 2 : union (\u222a)\n", "Working with sets is very similar to working with propositions.\nLet's now prove that any set $A$ is included in its union with \nany other set $B$, or $A \u2286 A \u222a B$. To work with unions you will\nneed to know the property which classifies them:\n\n```\nmem_union_iff : x \u2208 A \u222a B \u2194 x \u2208 A \u2228 x \u2208 B\n```\n\nYou need to get yourself into a situation where the left hand side\nof `mem_union_iff` is in your goal; that way, you can `rw mem_union_iff`\nand make progress.\n", "x \u2208 A \u222a B \u2194 x \u2208 A \u2228 x \u2208 B\n", "`intros` is like `intro` but can be used to introduce more than one\nthing at once. For example if your goal is `\u22a2 \u2200 (x : X), x \u2208 A \u2192 x \u2208 A \u222a B`\nthen `intros x hx` will do the same as `intro x, intro hx`.\n", "Tactic tip : intros", "We start with a rewrite (see level 1).\nThen, after introducing your terms, you'll be able to pull off\nthe second rewrite. Finally, you'll need to prove the `left`\nside of an `or` goal.\n", "Stuck?", "If $A$ and $B$ are sets of any type $X$, then\n$$ A \\subseteq A\\cup B.$$ \n", "end xena --hide\n", "import game.sets.sets_level02 -- hide\n", "namespace xena -- hide\n", "open_locale classical -- hide\n", "variable X : Type -- hide\n", "# Chapter 1 : Sets\n\n## Level 3 : intersection (\u2229)\n", "Now prove that for any two sets $A$ and $B$, $A \u2229 B \u2286 A$.\n   \nYou will need to rewrite the following term:\n\n```\nmem_inter_iff : x \u2208 A \u2229 B \u2194 x \u2208 A \u2227 x \u2208 B \n```\n", "x \u2208 A \u2229 B \u2194 x \u2208 A \u2227 x \u2208 B\n", "You need to start the same way as in the previous levels.\nTry and get yourself into a situation where you have a\n*hypothesis* `hAB : x \u2208 A \u2229 B` and then use `rw mem_inter_iff at hAB`. \n", "Stuck?", "By convention, \u2227 binds more tightly than \u2192\n(i.e. `x \u2208 A \u2227 x \u2208 B \u2192 x \u2208 A` means `(x \u2208 A \u2227 x \u2208 B) \u2192 x \u2208 A`)\n", "A note on `x \u2208 A \u2227 x \u2208 B \u2192 x \u2208 A`", "The `cases h with hP hQ` tactic turns `h : P \u2227 Q` into `hP : P` and `hQ : Q`\n", "Reminder about `cases`", "The `tauto!` tactic solves goals in propositional logic (i.e. problems where\nthe relevant hypotheses and goal just involve `\u2227`, `\u2228`, `\u00ac` and `\u2192` and\npropositions -- for example it could easily solve this goal:\n\n```\nh : P \u2227 Q\n\u22a2 P\n```\n", "The `tauto!` tactic", "If $A$ and $B$ are sets of any type $X$, then\n$$ A \\cap B \\subseteq A.$$\n", "end xena -- hide\n", "import game.sets.sets_level03 -- hide\n", "namespace xena -- hide\n", "open_locale classical -- hide\n", "variable X : Type --hide\n", "# Chapter 1 : Sets\n\n## Level 4\n", "A = B \u2194 \u2200 x : X, x \u2208 A \u2194 x \u2208 B\n", "\nTo prove that two sets are equal, one needs to use the axiom\nof extensionality: two sets are equal if and only if they have\nthe same elements.\n\nIn Lean's maths library this axiom is called `ext_iff`.\n\n```\nlemma ext_diff : A = B \u2194 \u2200 x : X, x \u2208 A \u2194 x \u2208 B\n```\n", "\nAfter a `split` statement, one goal turns into two. A good programming style\nwould be to use `{}` brackets to work on each goal individually, like this:\n```\nbegin\n  split,\n  { insert,\n    proof of,\n    first goal\n  },\n  { insert,\n    proof of,\n    second goal\n  }\nend\n```\n\nThis way you only ever have one goal to work on, and your code becomes\neasier to read. After `split` you might want to write \n```\n{ sorry},\n{ sorry}\n```\nso that your code has no errors while you're working on it.\n", "A word on coding style", "To prove the theorem below, remember that you can use `split` to \nchange the goal into two goals, corresponding to the left-right and\nright-left implication, respectively. For the first goal, after\n`intro h,` the equality of the two sets can be manipulated\nusing `rw ext_iff`.\n", "Stuck?", "`rw` doesn't work \"under a binder\". In other words, if your goal is\n`\u22a2\t\u2200 (x : X), x \u2208 B \u2194 x \u2208 A \u222a B` then `rw mem_union_iff` won't work!\nIt's the `\u2200` which is blocking it. Either do `intro x` (and then\nthe `rw` will work), or use a more powerful rewrite tactic\ncalled `simp_rw`, which will work \n\n", "rewrite failures and the `simp_rw` tactic", "If $A$ and $B$ are sets of any type $X$, then\n$$ A \\subseteq B \\iff A \\cup B = B.$$\n", "--begin hide\n-- theorem subset_iff_union_eq' (A : set X) (B : set X) : A \u2286 B \u2194 B = A \u222a B := \n-- begin\n--   rw subset_iff,\n--   rw ext_iff,\n--   apply forall_congr,\n--   intro x,\n--   rw mem_union_iff,\n--   tauto!,\n-- end\n--end hide\n", "end xena --hide\n", "import game.sets.sets_level04 -- hide\n", "namespace xena -- hide\n", "open_locale classical -- hide\n", "variable X : Type --hide\n", "# Chapter 1 : Sets\n\n## Level 5\n", "If `h : \u2200 (x : X), x \u2208 A \u2192 x \u2208 B` then `h` is a function which takes\na term `x` of type `X` as input, and also a proof that `x \u2208 A`, and outputs a\nproof that `x \u2208 B`. If you want to run this function `h` on some term `a : X`\nthen any of the following work:\n\n```\nhave h2 := h a,\nreplace h := h a,\nspecialize h a\n```\n\nThe first one preserves `h` and creates a new hypothesis `h2`. The others\nreplace `h` with `h : a \u2208 A \u2192 a \u2208 B`.\n", "If $A$ and $B$ are sets of any type $X$, then\n$$ A \\subseteq B \\iff A \\cap B = A.$$\n", "-- theorem subset_iff_intersection_eq' (A : set X) (B : set X) : A \u2286 B \u2194 A \u2229 B = A := \n-- begin\n--   rw subset_iff,\n--   rw eq_iff,\n--   apply forall_congr, -- clever trick\n--   intro x,\n--   rw mem_inter_iff, -- no longer under a binder\n--   tauto!\n-- end\n", "end xena -- hide", "import game.sets.sets_level05 -- hide\n", "import tactic -- hide\n", "namespace xena -- hide\n", "variable X : Type\n", "open_locale classical -- hide\n", "# Chapter 1 : Sets\n\n## Level 6 : `sdiff` and `neg`\n", "\nThe set-theoretic difference `A \\ B` satisfies the following property:\n\n```\nlemma mem_sdiff_iff : x \u2208 A \\ B \u2194 x \u2208 A \u2227 x \u2209 B\n```\n\nThe complement `-A` of a set `A` (often denoted $A^c$ in textbooks)\nis all the elements of `X` which are not in `A`:\n\n```\nlemma mem_neg_iff : x \u2208 -A \u2194 x \u2209 A\n```\n\nIn this lemma, you might get a shock. The `rw` tactic is aggressive\nin the Real Number Game -- if after a rewrite the goal can be\nsolved by `refl`, then Lean will close the goal automatically.\n\n", "x \u2208 A \\ B \u2194 x \u2208 A \u2227 x \u2209 B\n", "x \u2208 -A \u2194 x \u2209 A\n", "If $A$ and $B$ are sets with elements of type $X$, then\n$$(A \\setminus B) = A \\cap B^{c}.$$\n", "end xena -- hide\n", "import tactic --hide\n", "import game.sets.sets_level06 -- hide\n", "variable X : Type --hide\n", "open_locale classical -- hide\n", "namespace xena -- hide\n", "# Chapter 1 : Sets\n\n## Level 7 : The empty set\n", "\nThe way to handle the empty set is the following:\n\n```\nlemma mem_empty_iff (a : X) : a \u2208 (\u2205 : set X) \u2194 false\n```\n", "a \u2208 (\u2205 : set X) \u2194 false\n", "Remember that `exfalso` changes any goal to `false`. This can be\nconvenient if your hypotheses can prove `false`.\n\nAnother approach: if `hx : false` then `cases hx` will do a case\nsplit into every proof of false -- but there are no proofs of\nfalse! So there will be no cases left to do.\n", "Stuck?", "The empty set is a subset of any set $A$. \n", "end xena", "import kb_real_defs --hide\n", "# Chapter 1 : Sets\n\n## Level 8\n", "This is a very basic example of working with intervals of real numbers in Lean.\nAn interval `[a, b]` that is closed at both endpoints $a$ and $b$ can be \nconstructed using `set.Icc a b`. For an open-closed interval `(a, b]`,\nthe notation\nis `set.Ioc a b`, etc. The usual closed-interval notation, using square\nbrackets, is used here as a wrapper around these definitions. We have\nthe following lemma:\n\n\n\n```\nmem_Icc_iff : x \u2208 Icc a b \u2194 a \u2264 x \u2227 x \u2264 b\n```\n", "x \u2208 Icc a b \u2194 a \u2264 x \u2227 x \u2264 b\n", "After rewriting it, the `split` tactic will isolate the two conditions for \nmembership. Each inequality goals can be solved with the `norm_num` tactic,\nwhich closes goals which are equalities or inequalities between explicit\nreal numbers.\n", "/- Pro tip : semicolons\nIf instead of a comma, you end a line with a semicolon, then\nLean will apply the next tactic to all the goals created by the\nprevious tactic, rather than just the top one.\n-/\n/- Pro tip : definitional equality\n`mem_Icc_iff` is true by definition, so you don't actually\nhave to even rewrite it.\n-/\nnotation `[` a `,` b `]`  := set.Icc a b\n", "$2 \u2208 [0,5]$\n", "import kb_real_defs\n", "# Chapter 1 : Sets\n\n## Level 9\n", "This is a little more complicated example asking you to work with intervals of reals.\nThe result will be of help in the sup-inf world.\n", "notation `[` a `,` b `]`  := set.Icc a b\ndef mem_prod_sets (A : set \u211d) (B : set \u211d) := { x : \u211d | \u2203 y \u2208 A, \u2203 z \u2208 B, x = y * z}\n", "If $x = 0$, then `x \u2208 mem_prod_sets [(-2:\u211d),-1] [(0:\u211d), 3]`\n", "import data.real.basic\n", "# Chapter 1 : Sets\n\n## Level 10\n\nAs a final test of your ability in working with sets, prove that the set of rational \nnumbers is dense in the reals.\n\nThis proof will, among other things, rely on several new axioms that appear\nin the left side bar.\nNote that you may need to change the type of some quantities from rationals to reals.\nLean doesn't necessarily consider the rational $2$ to be the same at the real number $2$.\nSome of the axioms on the left make working with the casts from rationals to reals easier.\n", "\u2200 n : \u2115, 0 < n \u2192 (1/n : \u211d) * (n : \u211d ) = 1 \n", "\u2200 (m : \u2124), \u2200 (n : \u2115), 0 < n \u2192 (1/n : \u211d) * (m : \u211d) = (m/n : \u211d)\n", "", "", "-- one way to prove \u211a dense in \u211d \ndef dense_in_R (A : set \u211d) := \u2200 (x y : \u211d), x < y \u2192 \u2203 a \u2208 A, a \u2208 set.Ioo x y\ndef embedded_rationals : set \u211d := { x | \u2203 r : \u211a, x = \u2191r }\n", "axiom archimedean_R : \u2200 x : \u211d, 0 < x \u2192 \u2203 n : \u2115, 0 < n \u2227 (1/n : \u211d) < x\n-- we might want to prove these below. Made into axioms just for ease.\n-- the problem is that the proofs are too hard for this level, IMO (DS)\naxiom has_ceiling : \u2200 x : \u211d,  \u2203 m : \u2124, ((m-1) : \u211d) \u2264 x \u2227 x < (m:\u211d)\naxiom inv_prod_self : \u2200 n : \u2115, 0 < n \u2192 (1/n : \u211d) * (n : \u211d ) = 1 \naxiom inv_prod_other : \u2200 (m : \u2124), \u2200 (n : \u2115), 0 < n \u2192 (1/n : \u211d) * (m : \u211d) = (m/n : \u211d)\n", "Rationals are dense in the reals.\n", "Order", "import game.sets.sets_level10\nimport data.real.basic\n", "namespace xena -- hide\n", "# Chapter 2 : Order\n\n## Level 1\n\nThis level aims to familiarize you with the use of the trichotomy property in \nLean, as it will come in handy in later levels.\nThis property is stated in Lean's mathlib is:\n\n`lt_trichotomy : \u2200 (a b : ?M_1), a < b \u2228 a = b \u2228 b < a`\n\nand you can just use it to finish the proof below.\n", "For any two real numbers $a$ and $b$, we have that\n$$ a < b \\lor a = b \\lor b < a$$.\n", "end xena --hide\n", "import data.real.basic\nimport game.order.level01\n", "namespace xena -- hide\n", "# Chapter 2 : Order\n\n## Level 2\n\nThis level invites you to work out a property of the absolute value.\nIn Lean the absolute value of $x$ is denoted by `abs x`. \n", "definition abs {\u03b1 : Type u} [decidable_linear_ordered_add_comm_group \u03b1] (a : \u03b1) : \u03b1 := max a (-a)\n", "The definition of the absolute value in mathlib:", "For ease of use, a notation can be wrapped around that definition as below.\n", "notation `|` x `|` := abs x\n", "For any two real numbers $a$ and $b$, we have that\n$$|ab| = |a||b|$$.\n", "end xena --hide\n", "import game.order.level02\n", "namespace xena -- hide\n", "# Chapter 2 : Order\n\n## Level 3\n\nAnother property of the absolute value.\n", "notation `|` x `|` := abs x --hide\n", "For any two real numbers $a$ and $b$, we have that\n$$|a| \u2264 c \u2194 -c \u2264 a \u2264 c$$.\n", "end xena --hide\n", "import game.order.level03\n", "namespace xena -- hide\n", "# Chapter 2 : Order\n\n## Level 4\n\nThis level invites you to work out a property of the absolute value.\nIn Lean the absolute value of $x$ is denoted by `abs x`. \nFor ease of use, a notation can be used around that definition as below.\nFeel free to use the triangle inequality on the real numbers,\n\n`abs_add : \u2200 (a b : ?M_1), |a + b| \u2264 |a| + |b|`\n\ntogether with the `linarith` and `norm_num` tactics.\n", "notation `|` x `|` := abs x\n", "For any two real numbers $a$ and $b$, we have that\n$$| a - b| \u2264 |a| + |b|$$.\n", "end xena --hide\n", "import game.order.level04\n", "namespace xena -- hide\n", "# Chapter 2 : Order\n\n## Level 5\n\nAnother well-known property of the absolute value.\n", "notation `|` x `|` := abs x -- hide\n", "For any two real numbers $a$ and $b$, we have that\n$$| |a| - |b| | \u2264 |a - b|$$.\n", "end xena --hide\n", "import game.order.level05\nimport data.real.basic\nopen real\n", "namespace xena -- hide\n", "# Chapter 2 : Order\n\n## Level 6\n\nAn interesting result to prove.\n", "For any two non-negative real numbers $a$ and $b$, we have that\n$$a \\le b \\iff a^2 \\le b^2 $$.\n", "end xena -- hide", "import game.order.level06\nimport data.real.irrational\nopen real\n", "namespace xena -- hide\n", "# Chapter 2 : Order\n\n## Level 7\n\nProve by example that there exist pairs of real numbers\n$a$ and $b$ such that $a \\in \\mathbb{R} \\setminus \\mathbb{Q}$, \n$b \\in \\mathbb{R} \\setminus \\mathbb{Q}$,\nbut their sum $a + b$ is a rational number, $(a+b) \\in \\mathbb{Q}$.\nYou may use this result in the Lean mathlib library:\n\n`irrational_sqrt_two : irrational (sqrt 2)`\n\n", "", "Not true that for any $a$, $b$, irrational numbers, the sum is \nalso an irrational number.\n", "end xena -- hide\n", "import game.order.level07\nimport data.real.irrational\nopen real\n", "namespace xena -- hide\n", "# Chapter 2 : Order\n\n## Level 8\n\nProve by example that there exist pairs of real numbers\n$a$ and $b$ such that $a \\in \\mathbb{R} \\setminus \\mathbb{Q}$, \n$b \\in \\mathbb{R} \\setminus \\mathbb{Q}$,\nbut their product $a \\cdot b$ is a rational number, $(a \\cdot b) \\in \\mathbb{Q}$.\nYou may use this result in the Lean mathlib library:\n\n`irrational_sqrt_two : irrational (sqrt 2)\n", "Not true that for any $a$, $b$, irrational numbers, the product is \nalso an irrational number.\n", "end xena -- hide\n", "import game.order.level08\nopen real\n", "namespace xena -- hide\n", "# Chapter 2 : Order\n\n## Level 9\n\nThis level invites you to work out a property of the absolute value.\nIn Lean the absolute value of $x$ is denoted by `abs x`. \nFor ease of use, a notation can be used around that definition as below.\nFeel free to use the triangle inequality on the real numbers,\n\n`abs_add : \u2200 (a b : ?M_1), |a + b| \u2264 |a| + |b|`\n\ntogether with the `linarith` and `norm_num` tactics.\n", "notation `|` x `|` := abs x\n", "-- this to go in the side bar\nlemma eq_sqr_to_eq (a b : \u211d) (ha : 0 \u2264 a) (hb : 0 \u2264 b) : a^2 = b^2 \u2192 a = b :=\nbegin\n    intro H,\n    have A : sqrt (a ^ 2) = sqrt (a ^ 2), refl,\n    rw H at A {occs := occurrences.pos [2]},\n    have G := sqrt_sqr ha, rw G at A,\n    have F := sqrt_sqr hb, rw F at A, \n    exact A, done\nend\n", "For any two real numbers $a$ and $b$, we have that\n$$|a + b| = |a| + |b|$$ if and only if $ab \\ge 0$ .\n", "end xena -- hide\n", "Sup and Inf", "import game.order.level09\nimport data.real.basic -- imports the real numbers \u211d\n", "namespace xena -- hide\n", "-- World name : Sup and Inf\n", "# Chapter 3 : Sup and Inf\n\n## Level 1 : Upper bounds\n", "Let $X$ be a set of real numbers.\n\nWe say a real number $b$ is an *upper bound* for $X$ if every $x \\in X$ is at most $b$.\n", "definition is_upper_bound (S : set \u211d) (x : \u211d) := \u2200 s \u2208 S, s \u2264 x \n", "Here is an easy fact about upper bounds, which we shall prove below: \nIf $X \\subseteq Y$ are two sets of reals, and $b$ is an upper bound for $Y$, \nthen it's also an upper bound for $X$.\n\nYou can prove this easily in Lean using the `change` tactic. \n", "If $X \\subseteq Y$ are two sets of reals, and $b$ is an upper bound for $Y$, \nthen it's also an upper bound for $X$.\n", "end xena -- hide\n", "import game.sup_inf.level01\n", "namespace xena -- hide\n", "-- World name : Sup and Inf\n", "# Chapter 3 : Sup and Inf\n\n## Level 2  \n\n", "The completeness axiom on the reals states that any non-empty subset \n$X \\subseteq \\mathbb{R}$ that is bounded above has a least upper bound.\nHere we explore the converse statement: any set of reals that has a supremum is non-empty and \nhas an upper bound. The second part of the result is trivial, but showing that the\nset is non-empty will ask you to use techniques learned in the first world.\n", "-- definition is_upper_bound' (S : set \u211d) (x : \u211d) := x \u2208 upper_bounds S \n-- (Definition above deprecated? GT)\ndefinition is_lub (S : set \u211d) (x : \u211d) := is_upper_bound S x \u2227 \n\u2200 y : \u211d, is_upper_bound S y \u2192 x \u2264 y\ndefinition has_lub (S : set \u211d) := \u2203 x, is_lub S x \n", "local attribute [instance] classical.prop_decidable --hide\n", "Any set of reals that has a supremum is non-empty and bounded above.\n", "end xena -- hide\n", "import game.sup_inf.level02\nimport data.real.basic\n", "namespace xena -- hide\n", "# Chapter 3 : Sup and Inf\n\n## Level 3\n", "This level asks you to prove what the supremum of a given open set is.\n", "definition reals_lt_59 := {x : \u211d | x < 59}\n", "-- The next result must be placed in the sidebar axioms.\ntheorem helper_lemma (x y : \u211d) (H : x < y) : x < (x + y) / 2 \u2227 (x + y) / 2 < y :=\nbegin\n  have two_ge_zero : (2 : \u211d) \u2265 0 := by norm_num,\n  split,\n  { apply lt_of_mul_lt_mul_right _ two_ge_zero,\n    rw [mul_two,div_mul_cancel],\n    apply add_lt_add_left H,\n    norm_num},\n  { apply lt_of_mul_lt_mul_right _ two_ge_zero,\n    rw [div_mul_cancel,mul_two],\n    apply add_lt_add_right H,\n    norm_num,\n  },\nend\n", "The LUB of...\n", "end xena -- hide\n", "import game.sup_inf.level03\nimport data.real.basic\n", "namespace xena -- hide\n", "# Chapter 3 : Sup and Inf\n\n## Level 4 \n", "A generalization of the result in the previous level.\n", "-- these three helper results to go in sidebar\nlemma two_real_ne_zero : (2:\u211d) \u2260 0 :=\nbegin\n    intro, linarith,\nend\nlemma avg_lt_max {mn mx: \u211d} (H : mn < mx) : (mn+mx) / 2 < mx :=\nbegin\n  apply (mul_lt_mul_right (show (0:\u211d)<2, by norm_num)).1,\n  rw [div_mul_cancel _ (two_real_ne_zero)],\n  simp [H,mul_two],\nend\nlemma min_lt_avg {mn mx: \u211d} (H : mn < mx) : mn < (mn+mx) / 2 :=\nbegin\n  apply (mul_lt_mul_right (show (0:\u211d)<2, by norm_num)).1,\n  rw [div_mul_cancel _ (two_real_ne_zero)],\n  simp [H,mul_two],\nend\n", "A more general version of the previous level...\n", "end xena -- hide\n", "import game.sup_inf.level04\n", "namespace xena -- hide\n", "# Chapter 3 : Sup and Inf\n\n## Level 5\n\nA classical result: the supremum of an element-wise sum of sets.\n", "-- see also ds_infSum.lean for only the better-organized version -- hide\n", "def mem_sum_sets (A : set \u211d) (B : set \u211d) := { x : \u211d | \u2203 y \u2208 A, \u2203 z \u2208 B, x = y + z}\n", "If $A$ and $B$ are sets of reals, then\n$$ \\textrm{sup} (A + B) = \\textrm{sup} (A) + \\textrm{sup}(B)$$\n", "-- Kevin's term proof for second part\n-- NOTE: I altered this after is_lub changed. I don't *think* it's broken -- GT.\nlemma sup_sum_of_sets' (A : set \u211d) (B : set \u211d) (a : \u211d) (b : \u211d)\n  (hA : is_lub A a) (hB : is_lub B b) :\n  a + b \u2208 lower_bounds (upper_bounds (mem_sum_sets A B)) :=\n    \u03bb S hS, add_le_of_le_sub_left $ hB.2 (S - a) $ \u03bb z hz, le_sub.1 $ hA.2 (S - z) $ \u03bb y hy, \n    le_sub_right_of_add_le $ hS \u27e8y, hy, z, hz, rfl\u27e9\n-- Patrick Massot's proof for second part\nlemma sup_sum_of_sets'' (A : set \u211d) (B : set \u211d) (a : \u211d) (b : \u211d)\n  (hA : is_lub A a) (hB : is_lub B b) :\n  a + b \u2208 lower_bounds (upper_bounds (mem_sum_sets A B)) :=\nbegin\n    intros S hS,\n  have H1 : \u2200 x \u2208 A, S - x \u2208 upper_bounds B,\n  { intros x hx y hy,\n    suffices : x + y \u2264 S, by linarith, -- by rwa le_sub_iff_add_le',\n    exact hS \u27e8x, hx, y, hy, rfl\u27e9, },\n  have H2 : S - b \u2208 upper_bounds A,\n  { intros x hx,\n    suffices : b \u2264 S - x, by linarith, -- by rwa le_sub,\n    exact hB.2 (S - x) (H1 x hx) },\n  linarith [hA.2 (S - b) H2],  --exact le_sub_iff_add_le.mp (hA.2 H2),\nend\n--- end hide\nend xena -- hide\n", "import game.sup_inf.supSumSets\n", "namespace xena -- hide\n", "# Chapter 3 : Sup and Inf\n\n## Level 6\n\nThis level, very similar to the previous, showcases the infimum.\n", "def sum_of_sets (A : set \u211d) (B : set \u211d) := { x : \u211d | \u2203 y \u2208 A, \u2203 z \u2208 B, x = y + z}\n", "If $A$ and $B$ are sets of reals, then\n$$ \\textrm{inf} (A + B) = \\textrm{inf} (A) + \\textrm{inf}(B)$$\n", "end xena -- hide\n", "import game.sup_inf.infSumSets\n", "namespace xena -- hide\n", "# Chapter 3 : Sup and Inf\n\n## Level 7\n\nAnother level that showcases the infimum.\n", "def sum_set_const (A : set \u211d) (c : \u211d) := { x : \u211d | \u2203 y \u2208 A, x = y + c}\n", "If $A$ is a set of reals, then\n$$ \\textrm{inf} (c + A) = c + \\textrm{inf} (A)$$\n", "end xena -- hide\n", "import game.sup_inf.infSumConst\n", "namespace xena -- hide\n", "# Chapter 3 : Sup and Inf\n\n## Level 8\n\nAgain a classical result.\n", "-- supremum of constant \u00d7 set\ndef const_times_set (c: \u211d) (A : set \u211d) := { x : \u211d | \u2203 y \u2208 A, x = c * y }\n", "If $A$ is a set of reals and $c > 0$, then\n$$ \\textrm{sup} (cA) = c \\cdot \\textrm{sup} (A)$$\n", "end xena -- hide\n", "import ..sup_inf.supProdConst\nimport ..sets.sets_level09\n", "namespace xena -- hide\n", "# Chapter 3 : Sup and Inf\n\n## Level 9\n\nAn intermediary result to be used in the next level.\n", "-- main result in lemma sup_mem_prod_of_sets\n", "--def mem_prod_sets (A : set \u211d) (B : set \u211d) := { x : \u211d | \u2203 y \u2208 A, \u2203 z \u2208 B, x = y * z}\n", "Prove that a given real number is the supremum of a particular set.\n", "Given two sets of reals $A$ and $B$, show that given real number is the LUB\nof their elementwise product `mem_prod_sets`.\n", "end xena -- hide\n", "import .lub_prodSets\n", "namespace xena -- hide\n", "# Chapter 3 : Sup and Inf\n\n## Level 10\n", "-- main result in lemma sup_mem_prod_of_sets\n", "-- hide\n", "--def mem_prod_sets (A : set \u211d) (B : set \u211d) := { x : \u211d | \u2203 y \u2208 A, \u2203 z \u2208 B, x = y * z}\n", "Intermediary result `zero_in_prod` proved in sets_level08.\n\nIntermediary result `mem_prod_sets_lub_proof` in previous level.\n", "For two non-empty sets of reals $A$ and $B$, it is not in general true that\n$$ \\textrm{sup} (A \\cdot B) = \\textrm{sup} (A) \\cdot \\textrm{sup}(B)$$\nwhere $A \\cdot B$ is defined pointwise as above.\n", "end xena -- hide\n", "import game.sup_inf.supProdSets\n", "namespace xena -- hide\n", "# Chapter 3 : Sup and Inf\n\n## Level 11\n", "def embedded_rationals : set \u211d := {x : \u211d | \u2203 y : \u211a, x = \u2191y}\n", "The set of rational numbers does not have a supremum\n", "end xena -- hide\n", "import game.sup_inf.lub_rationals\nimport data.real.basic\n", "namespace xena -- hide\n", "# Chapter 3 : Sup and Inf\n\n## Level 12\n", "def unboundedAbove (A : set \u211d) := \u2200 x : \u211d, x > 0 \u2192 \u2203 a \u2208 A, x < a\n-- Might want to make this into an axiom to be placed on the left\ndef archimPrinciple := \u2200 x : \u211d, x > 0 \u2192  \u2203 n : \u2115, n > 0 \u2227 (1/n : \u211d) < x \n", "The Archimedean principle is equivalent to the set of natural numbers being unbounded above.\n", "end xena -- hide\n", "import game.sup_inf.unbdd_iff\nimport data.real.basic\n", "namespace xena -- hide\n", "# Chapter 3 : Sup and Inf\n\n## Level 13\n\nThis proof will be easy now.\nActually this needs quite some work due to coercions etc.\nMay need to change definitions.\n", "def bdd (X : set \u211d) := bdd_above X \u2227 bdd_below X\ndef complete (X : set \u211d) := \n    \u2200 Y : set \u211d, Y.nonempty \u2227 Y \u2286 X \u2227 bdd Y \u2192 \u2203 s \u2208 X, is_lub Y s \u2227 \u2203 i \u2208 X, is_glb Y i\n", "The rational numbers are not complete.\nNeed to complete the proof.\n", "end xena -- hide\n", "import game.sup_inf.rat_complete\n", "namespace xena --hide \n", "# Chapter 3 : Sup and Inf\n\n## Level 14\n", "The Least Upper Bound property implies\nGreatest Lower bound Property\n", "--NOTE: We have a form of the completeness axiom at Sup/Inf World\n--level 13.\n--Here I'll assume LUB property as an axiom, and prove it implies \n--GLB property. But perhaps `axiom` should be avoided. -- GT\n", "def is_bdd_above (S : set \u211d) := \u2203 x : \u211d, is_upper_bound S x    \ndef is_lower_bound (S : set \u211d) (x : \u211d) := \u2200 s \u2208 S, x \u2264 s\ndef is_bdd_below (S : set \u211d) := \u2203 x : \u211d, is_lower_bound S x\ndef is_glb (S : set \u211d) (x : \u211d) := is_lower_bound S x \u2227 \n\u2200 y : \u211d, is_lower_bound S y \u2192 y \u2264 x\ndef has_glb (S : set \u211d) := \u2203 x : \u211d, is_glb S x\n", "Completeness Axiom\n", "axiom lub_property_reals (S : set \u211d) : \n(S.nonempty \u2227 is_bdd_above S) \u2192 (has_lub S)\n", "LUB property implies GLB property\n", "end xena -- hide\n", "Limits of sequences", "import game.sets.L01defs\n--NOTE: the recursive import from previous world breaks run_cmd add_interactive below??\n--I think the problem comes from sup_inf.rat_complete\n--So I will import sup_inf in the next level\nimport data.real.basic\nimport tactic.linarith\n", "namespace xena -- hide\n", "notation `|` x `|` := abs x -- hide\n", "lemma zero_of_abs_lt_all (x : \u211d) (h : \u2200 \u03b5 > 0, |x| < \u03b5) : x = 0 :=\neq_zero_of_abs_eq_zero $ eq_of_le_of_forall_le_of_dense (abs_nonneg x) $ \u03bb \u03b5 \u03b5_pos, le_of_lt (h \u03b5 \u03b5_pos)\n", "-- The next few things should be hidden\n@[user_attribute]\nmeta def ineq_rules : user_attribute :=\n{ name := `ineq_rules,\n  descr := \"lemmas usable to prove inequalities\" }\nattribute [ineq_rules] add_lt_add le_max_left le_max_right\nmeta def inequality := `[linarith <|> apply_rules ineq_rules]\nrun_cmd add_interactive [`inequality]\n-- end of scary things\n", "-- World name : Sequences and limits\n", "# Chapter 3 : Sequences and limits\n\n# Level 1 : Introduction to sequences.\n\nLean's natural numbers start at zero, so it is convenient to let our sequences start from the zeroth term.\nIn other words, a sequence of reals will be $a_0, a_1, a_2, \\ldots$. \n", "Let's just step back for a minute and think about what a sequence really *is*. \nIf $n$ is a natural number then $a_n$ is a real number, \nso $n\\mapsto a_n$ is actually a function from natural numbers to real numbers. \nIf we just call this function $a$ then the $n$th term in the sequence\nwill be called `a(n)` or `a n` in Lean, rather than $a_n$, but this is OK.\n\nThe key definition we want is the concept of a limit of a sequence.\n", "definition is_limit (a : \u2115 \u2192 \u211d) (\u03b1 : \u211d) := \n  \u2200 \u03b5 : \u211d, 0 < \u03b5 \u2192 \u2203 N : \u2115, \u2200 n : \u2115, N \u2264 n \u2192 |a n - \u03b1| < \u03b5\n", "Let's now prove the basic fact that a sequence has at most one limit. \n", "If $a_n \\to \\ell$ and $a_n \\to m$ then $\\ell = m$. \n", "end xena -- hide\n", "import game.limits.L01defs\nimport game.sup_inf.GLBprop_if_LUBprop\n", "namespace xena -- hide\n", "notation `|` x `|` := abs x -- hide\n", "Another basic result for working with sequences.\n", "If $\\lim_{n \\to \\infty} a_n = \\alpha$ and $\\lim_{n \\to \\infty} b_n = \\beta$, then\n $\\lim_{n \\to \\infty} (a_n + b_n) = \\alpha + \\beta$\n", "end xena -- hide\n", "import game.limits.L01defs\nimport game.limits.seq_lim_add\n", "namespace xena -- hide\n", "notation `|` x `|` := abs x -- hide\n", "A basic result for working with sequences.\n", "If $\\lim_{n \\to \\infty} a_n = \\alpha$ and $c \\in \\mathbb{R}$, then\n $\\lim_{n \\to \\infty} (c \\cdot a_n) = c \\cdot \\alpha$\n", "end xena -- hide\n", "import game.limits.L01defs\nimport game.limits.seq_limitTimesConst\n", "namespace xena -- hide\n", "notation `|` x `|` := abs x -- hide\n", "Use the previous results to obtain linearity.\n", "If $\\lim_{n \\to \\infty} a_n = \\alpha$ and $\\lim_{n \\to \\infty} b_n = \\beta$\nand $c$ is a constant, then \n$\\lim_{n \\to \\infty} ( c * a_n + c * b_n) = c \\alpha + c \\beta$\n", "end xena -- hide\n", "import game.limits.L01defs\nimport game.limits.seq_limitLinear\nopen real\n", "namespace xena -- hide\n", "notation `|` x `|` := abs x -- hide\n", "Use previous results to obtain the limit of a product if individual limits\nfor the factors are both zero.\n", "If $\\lim_{n \\to \\infty} a_n = 0$ and $\\lim_{n \\to \\infty} b_n = 0$,\nthen \n$\\lim_{n \\to \\infty} ( a_n * b_n) = 0$\n", "end xena -- hide\n", "import game.limits.L01defs\nimport game.limits.seq_limitZeroProd\nopen real\n", "namespace xena -- hide\n", "notation `|` x `|` := abs x -- hide\n", "Use previous results to obtain the limit of a product in the general case.\n", "If $\\lim_{n \\to \\infty} a_n = \\alpha$, then \n$\\lim_{n \\to \\infty} (a_n - c) = \\alpha - c.$\n", "end xena\n", "import game.limits.L01defs\nimport game.limits.seq_limSeqSub\nopen real\n", "namespace xena -- hide\n", "notation `|` x `|` := abs x -- hide\n", "Use previous results to obtain the limit of a product in the general case.\nWork in progress.\n", "If $\\lim_{n \\to \\infty} a_n = \\alpha$ and $\\lim_{n \\to \\infty} b_n = \\beta$, then \n$\\lim_{n \\to \\infty} (a_n * b_n) = \\alpha * \\beta$\n", "end xena -- hide\n", "import game.limits.L01defs\nimport game.limits.seq_limitLinear\n", "notation `|` x `|` := abs x -- hide\n", "namespace xena -- hide\n", "A simple limit proof.\n", "-- The proof below is from M1P1-lean.\n", "Prove that the limit of $a_n = 1/n$ is zero.\n", "end xena -- hide\n", "import game.limits.L01defs\nimport game.limits.seq_proveLimit\nimport algebra.pi_instances\nimport game.order.level05\n--open function\nopen finset\n", "namespace xena -- hide\n", "notation `|` x `|` := abs x -- hide\n", "def is_convergent (a : \u2115 \u2192 \u211d) := \u2203 \u03b1 : \u211d, is_limit a \u03b1 \ndef is_Cauchy (a : \u2115 \u2192 \u211d) := \n  \u2200 \u03b5 : \u211d, 0 < \u03b5 \u2192 \u2203 N : \u2115, \u2200 m n : \u2115, N \u2264 m \u2227 N \u2264 n \u2192 |a m - a n| < \u03b5\ndef is_bdd (a : \u2115 \u2192 \u211d) := \u2203 B > 0, \u2200 n, |a n| \u2264 B \n", "-- We may want to skip this in RNG unless we can make it look (or be) easy --?\n", "Cauchy sequences are bounded.\n\n", "A Cauchy sequence is bounded.\n", "end xena -- hide\n", "import game.limits.L01defs\nimport game.limits.seq_cauchyBdd\n", "namespace xena -- hide\n", "notation `|` x `|` := abs x -- hide\n", "Relationship convergent/Cauchy sequences.\n\nWork in progress.\n", "A convergent sequence of real numbers is a Cauchy sequence.\nProve \"if and only if\": WIP. \n", "end xena -- hide\n", "--example (a b c d : \u211d) (h1 : a \u2264 b + c) : a - b \u2264 c  := by library_search\n--example ( a : \u211d ) : |a| = | - a | := by library_search\n", "import game.limits.seq_convCauchy\n", "namespace xena -- hide\n", "notation `|` x `|` := abs x -- hide\n", "Another useful result for working with sequences -- a convergent sequence is bounded.\n", "We define the concepts of a bounded sequence, in much the same way\nthat we defined the concepts of a limit and a convergent sequence. \n", "NOTE: limits/seq_cauchyBdd.lean introduces the definition\n\nis_bdd (a : \u2115 \u2192 \u211d) := \u2203 B > 0, \u2200 n, |a n| \u2264 B \n\nHere I omit the B > 0 condition (which follows from properties of abs?)\nBut this level is perhaps superfluous anyway.\n", "definition is_bound (a : \u2115 \u2192 \u211d) (M : \u211d) := \u2200 n, | a n | \u2264 M\ndefinition is_bounded (a : \u2115 \u2192 \u211d) := \u2203 M, is_bound a M\n", "A convergent sequence is bounded.\n", "end xena -- hide\n", "import game.limits.bounded_if_convergent\nnamespace xena\n", "\"Shift rule\" for sequences, used in Series world:\n", "Shift rule\n", "end xena\n", "import game.limits.shift_rule_seq\n", "namespace xena --hide \n", "Bounded monotone sequences converge\n", "It is obvious that a sequence of real numbers is bounded if and only if \nthe set of its terms is bounded above and bounded below in \u211d. For that\nreason you may wish to skip the proof of the following proposition, which \nwe will use in our proof of the monotone convergence theorem.\n", "end xena -- hide\n", "import game.limits.seq_bdd_iff_range_bdd\n", "namespace xena --hide \n", "Bounded monotone sequences converge\n", "def is_increasing (a : \u2115 \u2192 \u211d) := \u2200 n : \u2115, a n \u2264 a (n+1)\ndef is_decreasing (a : \u2115 \u2192 \u211d) := \u2200 n : \u2115, a (n + 1) \u2264 a n\ndef is_monotone (a : \u2115 \u2192 \u211d) := is_increasing a \u2228 is_decreasing a\n", "-- Note: later we use (n \u2264 k) \u2192 (a n \u2264 a k) for `a` monotone increasing\n-- and (n \u2264 k) \u2192 (a k \u2264 a n) for decreasing. Should these be proved first,\n-- or use mathlib's versions of monotone? \n--https://leanprover-community.github.io/mathlib_docs/order/basic.html\ntheorem is_increasing' (a : \u2115 \u2192 \u211d) : is_increasing a \u2194 (\u2200 m n : \u2115, \n m \u2264 n \u2192 a m \u2264 a n) := \nbegin\nsplit,\nintros inc m n,\n{intro hyp,\ninduction hyp with k hyp ihyp,\nexact le_refl (a m),\nexact le_trans ihyp (inc k),},\nintros hyp p,\nexact (hyp p (p + 1)) (nat.le_succ p),\nend\ntheorem is_decreasing' (a : \u2115 \u2192 \u211d) : is_decreasing a \u2194 (\u2200 m n : \u2115, \n m \u2264 n \u2192 a n \u2264 a m) := \nbegin\nsplit,\nintros dec m n,\n{intro hyp,\ninduction hyp with k hyp ihyp,\nexact le_refl (a m),\nexact le_trans (dec k) ihyp,},\nintros hyp p,\nexact (hyp p (p + 1)) (nat.le_succ p),\nend\n", "Bounded monotone sequences converge. \n", "end xena -- hide\n", "Series", "import game.series.L01defs\nnamespace xena \n", "-- if we want to use sigma notation, use \n-- import algebra.big_operators\n-- open_locale big_operators \n-- https://leanprover-community.github.io/mathlib_docs/algebra/big_operators.html\n", "If $\\sum a_n$ converges, then $a_n \\to 0$.\n\nWe take the approach of showing that $(S_n) \u2192 M$ then $(S_{n+1}) \u2192 M$,\nand then using the fact that $a_{n+1} = S_{n+1} - S_n$.\n", "def kth_partial_sum (a : \u2115 \u2192 \u211d) (k : \u2115) := (finset.range (k+1)).sum a\ndef seq_partials_over (a : \u2115 \u2192 \u211d ) : \u2115 \u2192 \u211d := (\u03bb (n : \u2115), kth_partial_sum a n )\ndef series_converges (a : \u2115 \u2192 \u211d) := is_convergent (seq_partials_over a)\n", "If partial sum sequence of $a_n$ convergent, $a_n \u2192 0$.\n", "end xena\n", "import game.series.tempLevel01\n", "variable X : Type --hide\n", "namespace xena\n", "Idea 02: if $\\forall n \\in \\mathbb{N}, a_n \\ge 0$,\n$\\sum a_n$ converges iff partial sums bounded above.\n", "If $A$ and $B$ are sets of any type $X$, then\n$$ A \\subseteq A\\cup B.$$ \n", "end xena", "import game.series.tempLevel02\n", "variable X : Type --hide\n", "namespace xena\n", "Idea 03: comparison test\n", "Suppose $0 \u2264 a_n \u2264 b_n$ for all n \u2208 \u2115. If $\u2211 b_n$ converges\nthen $\u2211 a_n$ converges and $\u2211 a_n \u2264 \u2211 b_n$.\n", "end xena", "import game.series.L01defs\n", "variable X : Type --hide\n", "Idea 04: root test\n", "If $A$ and $B$ are sets of any type $X$, then\n$$ A \\subseteq A\\cup B.$$ \n", "Functions", "import data.real.basic\nopen function\n", "# Chapter 6 : Functions\n\n## Level 1\n\nA classical result in composition of functions.\n", "If $f : X \\to Y$ and $g : Y \\to Z$ are both injective functions, then\nthe function resulting from their composition is also injective.\n", "import data.real.basic\nopen function\n", "# Chapter 6 : Functions\n\n## Level 2\n\nA classical result in composition of functions.\n", "If $f : X \\to Y$ and $g : Y \\to Z$ are both surjective functions, then\nthe function resulting from their composition is also surjective.\n", "import data.real.basic\nimport game.functions.bothInjective game.functions.bothSurjective\nopen function\n", "# Chapter 6 : Functions\n\n## Level 3\n\nBe sure to make use of the results in the previous two levels.\n", "If $f : X \\to Y$ and $g : Y \\to Z$ are both bijective functions, then\nthe function resulting from their composition is also bijective.\n", "import data.real.basic\nopen function\n", "# Chapter 6 : Functions\n\n## Level 4\n\nA classical result in composition of functions.\n", "-- inverses\ndef two_sided_inverse {X Y : set \u211d} (f : X \u2192 Y) (g : Y \u2192 X) \n:= (\u2200 x : X, (g \u2218 f)(x) = x) \u2227 (\u2200 y : Y, (f \u2218 g)(y) = y)\n", "A function $f : X \u2192 Y$ has a two-sided inverse if and only if it is a bijection.\n", "import data.real.basic\nopen function\n", "# Chapter 6 : Functions\n\n## Level 5\n\nA classical result in composition of functions.\nNow going the other way around.\n", "If composition of $f$ and $g$ is injective, then $f$ is injective.\n", "import data.real.basic\nopen function\n", "# Chapter 6 : Functions\n\n## Level 6\n\nA classical result in composition of functions.\nNow going the other way around.\n", "If composition of $f$ and $g$ is surjective, then $g$ is injective.\n", "import data.real.basic\nopen function\nopen real\n", "Classic eps-delta definition of continuity.\nUse it to prove continuity at one point for a simple function.\nTo be proved equivalent to topological definition in topology world.\n\nWork in progress.\n", "notation `|` x `|` := abs x\ndef continuous_at_x (f : \u211d \u2192 \u211d) (x : \u211d) := \n    \u2200 \u03b5 : \u211d, 0 < \u03b5 \u2192 \u2203 \u03b4 : \u211d, 0 < \u03b4 \u2227 \u2200 y : \u211d, |x - y| < \u03b4 \u2192 |f x - f y| < \u03b5\ndef square_f (x : \u211d) := x^2\n", "The function $f(x) = x^2$ is continuous at $x=3$.\n", "import data.real.basic\n", "namespace xena -- hide\n", "open function\nopen real\nopen_locale classical\n", "Classic eps-delta definition of continuity is equivalent to \nthe definition using sequences.\n", "notation `|` x `|` := abs x\ndef is_limit (a : \u2115 \u2192 \u211d) (l : \u211d) := \n    \u2200 \u03b5 : \u211d, 0 < \u03b5 \u2192 \u2203 N : \u2115, \u2200 n : \u2115, N \u2264 n \u2192 |a n - l| < \u03b5\ndef continuous_at_x (f : \u211d \u2192 \u211d) (x : \u211d) := \n    \u2200 \u03b5 : \u211d, 0 < \u03b5 \u2192 \u2203 \u03b4 : \u211d, 0 < \u03b4 \u2227 \u2200 y : \u211d, |y - x| < \u03b4 \u2192 |f y - f x| < \u03b5\ndef seq_continuous_at_x (f : \u211d \u2192 \u211d) (x : \u211d) :=\n    \u2200 (a : \u2115 \u2192 \u211d), is_limit a x \u2192 is_limit ( \u03bb n : \u2115, f (a n) ) (f x)\n", "The two definitions of continuity are equivalent.\n", "end xena -- hide\n", "Cardinality", "import data.real.basic\nimport topology.basic\nopen function\nopen set\n", "namespace xena -- hide\n", "# Chapter 7 : Cardinality\n\n## Level 1\n\nA classical result about finite sets.\n", "local attribute [instance] classical.prop_decidable\n", "If $f : X \\to Y$ is an injective function and $Y$ is finite, then\n$X$ is also finite.\n", "end xena -- hide\n", "import data.real.basic\nimport topology.basic\nopen function\nopen set\n", "namespace xena -- hide\n", "# Chapter 7 : Cardinality\n\n## Level 2\n\nA classical result about finite sets.\n", "local attribute [instance] classical.prop_decidable\n", "If $f : X \\to Y$ is an injective function and $Y$ is finite, then\n$X$ is also finite.\n", "end xena -- hide\n", "--#check finite_subsets_of_finite\n", "import data.real.basic\nimport topology.basic\nopen function\nopen set\n", "namespace xena -- hide\n", "# Chapter 7 : Cardinality\n\n## Level 3\n\nA classical result about countable sets.\n", "If $f : X \\to Y$ is an injective function and $Y$ is countable, then\n$X$ is also countable.\n", "end xena -- hide\n", "-- term mode proof due to Kenny Lau\ntheorem countable_inj_2 (X Y : set \u211d) (f : X \u2192 Y) (hY : countable Y) :\n    injective f \u2192 countable X :=\n\u03bb hf, let \u27e8g, hg\u27e9 := countable_iff_exists_injective.1 hY in\ncountable_iff_exists_injective.2 \u27e8g \u2218 f, injective.comp hg hf\u27e9\n", "Integral", "import data.real.basic\nimport data.vector\nopen real\n", "variable X : Type -- hide\n", "# Work in progress.\n\n", "--#check finset\n--#check finset.card_range\n--#check list\n--Do we want a list? A vector? \n--either way, not sure how to go about this yet\n--def partition (a b : \u211d) (A: set.Icc a b) (n : \u2115) := list \u211d\n", "If $A$ and $B$ are sets of any type $X$, then\n$$ A \\subseteq A\\cup B.$$ \n", "Topology of the reals", "import data.real.basic\nimport data.set.lattice\nopen set\n--begin hide\nnamespace xena\n-- This will eventually be the first level, containing basic definitions\n-- Work in progress\n-- First I used \u2282 in the definition, then changed to \u2286 \n-- in order to be able to use subset.trans -- DS\n-- end hide\ndef is_open (X : set \u211d) := \u2200 x \u2208 X, \u2203 \u03b4 > 0, { y : \u211d  | x - \u03b4 < y \u2227 y < x + \u03b4 } \u2286 X\nvariable \u03b2 : Type\n", "-- Checking definitions\n--def countable_union (X : nat \u2192 set \u211d) := {t : \u211d | exists i, t \u2208 X i}\n", "Arbitrary union of open sets is open -- WIP, to do.\n", "end xena -- hide", "import data.real.basic\nimport data.set.lattice\nimport topology.basic\nimport game.topology.union_open_sets\nopen set\n--begin hide\nnamespace xena\n-- Work in progress\n-- end hide\n", "-- Checking mathlib definitions\nvariable \u03b2 : Type*  \nvariable [fintype \u03b2]\n", "Finite intersection of open sets is open -- WIP, to do.\n", "end xena -- hide\n", "import data.real.basic\nimport data.set.lattice\nimport topology.basic\nimport game.topology.union_open_sets\nopen set\n--begin hide\nnamespace xena\n-- end hide\ndef is_closed (X : set \u211d) := is_open {x : \u211d | x \u2209 X }\n", "-- Checking mathlib definitions\nvariable \u03b2 : Type*  -- finite unions only\nvariable [fintype \u03b2]\n", "Finite union of closed sets is closed -- WIP, to do.\n", "end xena -- hide", "import data.real.basic\nimport data.set.lattice\nimport topology.basic\nimport game.topology.union_closed_sets\nopen set\n--begin hide\nnamespace xena\n-- Work in progress\n-- end hide\n", "-- Checking mathlib definitions\nvariable \u03b2 : Type*\n", "Arbitrary intersection of closed sets is closed -- WIP, to do.\n", "end xena -- hide\n", "import data.real.basic\n--begin hide\nnamespace xena\ndef neighborhood1 (a : \u211d) (\u03b5 : \u211d) (h : \u03b5 > 0) := { x : \u211d | abs(a - x) < \u03b5}\n", " To be technically correct, the definition below should include \n the hypothesis that \u03b5 > 0, see the one above.\n But that does raise some issues which I don't know how to handle\n when using it in the main result lemma.\n", "-- end hide\ndef neighborhood (a : \u211d) (\u03b5 : \u211d) := { x : \u211d | abs(a - x) < \u03b5} \n", "local attribute [instance] classical.prop_decidable --hide\n", "Hausdorff property for the reals.\n", "end xena -- hide\n", "import data.real.basic\nimport topology.basic\n", "namespace xena -- hide\n", "open function\nopen real\nopen set\n", "Classic eps-delta definition of continuity equivalent to topological definition.\n\nWork in progress.\n", "notation `|` x `|` := abs x\ndef continuous_at_x (f : \u211d \u2192 \u211d) (x : \u211d) := \n    \u2200 \u03b5 : \u211d, 0 < \u03b5 \u2192 \u2203 \u03b4 : \u211d, 0 < \u03b4 \u2227 \u2200 y : \u211d, |x - y| < \u03b4 \u2192 |f x - f y| < \u03b5\ndef continuous_on_set (f : \u211d \u2192 \u211d) (X : set \u211d) :=\n    \u2200 x \u2208 X, continuous_at_x f x\ndef open_in_R (Y : set \u211d) := \u2200 x \u2208 Y, \u2203 \u03b5 : \u211d, 0 < \u03b5 \u2227 { y | |x-y| < \u03b5 } \u2282 Y\ndef open_in_X (S : set \u211d) (X : set \u211d) (hS : S \u2282 X) := \u2203 Y : set \u211d, \n    S = Y \u2229 X \u2227 open_in_R Y \ndef preimage_in_X (f : \u211d \u2192 \u211d) (X : set \u211d) (T : set \u211d) :=\n    { x | x \u2208 X \u2227 \u2203 t \u2208 T, f x = t}\ndef continuous_on_topo_def (f : \u211d \u2192 \u211d) (X : set \u211d) :=\n    \u2200 T : set \u211d, open_in_R T \u2192 open_in_R (preimage_in_X f X T)\n", "theorem continuous_on_topo_def2 (f : \u211d \u2192 \u211d) (X : set \u211d) :\n  \u2200 x \u2208 X, \u2200 t : set \u211d, is_open t \u2192 f x \u2208 t \u2192 \u2203 u, is_open u \u2227 x \u2208 u \u2227\n    u \u2229 X \u2286 f \u207b\u00b9' t :=\n", "Equivalent definitions of continuity.\n", "end xena\n", "Max", "import tactic -- hide\n", "import data.real.basic -- imports the real numbers\n", "\n", "open_locale classical -- allow proofs by contradiction\n", "\n", "noncomputable theory -- don't fuss about the reals being noncomputable\n", "namespace xena -- hide\n", "-- Let a, b, c be real numbers\nvariables {a b c : \u211d}\n", "# Chapter ? : Max and abs\n\n## Level 1\n\nIn this chapter we develop a basic interface for the `max a b` and `abs a`\nfunction on the real numbers. Before we start, you will need to know\nthe basic API for `\u2264` and `<`, which looks like this:\n\n```\nexample : a \u2264 a := le_refl a\n\nexample : a \u2264 b \u2192 b \u2264 c \u2192 a \u2264 c := le_trans\n\nexample : a \u2264 b \u2192 b \u2264 a \u2192 a = b := le_antisymm\n\nexample : a \u2264 b \u2228 b \u2264 a := le_total a b\n\nexample : a < b \u2194 a \u2264 b \u2227 a \u2260 b := lt_iff_le_and_ne\n\nexample : a \u2264 b \u2192 b < c \u2192 a < c := lt_of_le_of_lt\n\nexample : a < b \u2192 b \u2264 c \u2192 a < c := lt_of_lt_of_le\n```\n", "", "", "", "", "", "", "", "We start with `max a b := if a \u2264 b then b else a`. It is\nuniquely characterised by the following two properties, which are hence\nall you will need to know:\n\n```\ntheorem max_eq_right : a \u2264 b \u2192 max a b = b\n\ntheorem max_eq_left : b \u2264 a \u2192 max a b = a\n```\n", "", "", "def max (a b : \u211d) := if a \u2264 b then b else a\n-- need if_pos to do this one\ntheorem max_eq_right (hab : a \u2264 b) : max a b = b :=\nbegin\n  unfold max,\n  rw if_pos hab,  \nend\n-- need if_neg to do this one\ntheorem max_eq_left (hba : b \u2264 a) : max a b = a :=\nbegin\n  by_cases hab : a \u2264 b,\n  { rw max_eq_right hab,\n    exact le_antisymm hba hab,\n  },\n  { unfold max,\n    rw if_neg hab,\n  }\nend\n", "All of these theorems are in the theorem statement box on the left.\nSee if you can now prove the useful `max_choice` lemma using them.\n", "Do a case split with `cases le_total a b`. \n", "Hint", "For any two real numbers $a$ and $b$, either $\\max(a,b) = a$\nor $\\max(a,b) = b$.\n", "end xena --hide\n", "import game.max.level01 -- hide\n", "open_locale classical -- hide\n", "noncomputable theory -- hide\n", "namespace xena -- hide\n", "# Chapter ? : Max and abs\n\n## Level 2\n\n`max_comm` is the statement that `max a b = max b a`. See if you can prove it.\n", "Again, do a case split with `cases le_total a b`. \n", "Hint", "For any real numbers $a$ and $b$, we have $\\max(a,b) = \\max(b,a).$\n", "end xena --hide\n", "import game.max.level02 -- hide\n", "open_locale classical -- hide\n", "noncomputable theory -- hide\n", "namespace xena -- hide\n", "# Chapter ? : Max and abs\n\n## Level 3\n\n`le_max_left` is the statement that `a \u2264 max a b`.\n\nTechnical note: in contrast to the natural number game, the `rw` used\nin the real number game is Lean's more powerful `rw`, which automatically\ntries `refl` after a rewrite; note that `\u2264` is reflexive, so `refl` will\nclose a goal of the form `a \u2264 a`. \n", "For any real numbers $a$ and $b$, we have $a\\leq\\max(a,b).$\n", "end xena --hide\n", "import game.max.level03 -- hide\n", "open_locale classical -- hide\n", "noncomputable theory -- hide\n", "namespace xena -- hide\n", "# Chapter ? : Max and abs\n\n## Level 4\n\n`le_max_right` is the statement that `b \u2264 max a b`. There's a short\nproof using what we've already done.\n", "Why not start with `rw max_comm`?\n", "", "For any real numbers $a$ and $b$, we have $b\\leq\\max(a,b).$\n", "end xena --hide\n", "import game.max.level04 -- hide\n", "open_locale classical -- hide\n", "noncomputable theory -- hide\n", "namespace xena -- hide\n", "# Chapter ? : Max and abs\n\n## Level 5\n\n`max_le` is really useful; it says that if `a \u2264 c` and `b \u2264 c`\nthen `max a b \u2264 c`.\n\nNote that in the Lean formulation, the variables are *implicit*,\nmeaning that Lean will guess them.\n", "If $a$, $b$, $c$ are real numbers with $a\\leq c$ and $b\\leq c$,\nthen $\\max(a,b)\\leq c.$\n", "end xena --hide\n", "import game.max.level05 -- hide\n", "open_locale classical -- hide\n", "noncomputable theory -- hide\n", "namespace xena -- hide\n", "# Chapter ? : Max and abs\n\n## Level 6\n\nIn fact `max_le` can be beefed up to an iff statement.\n", "If your goal is `x \u2264 z` and you have a hypothesis `h : y \u2264 z`\nthen of course it will suffice to prove `x \u2264 y` and then you\ncan use transitivity. Instead of `have hxy : x \u2264 y,`, opening\na new goal and adding a new hypothesis to our list, you can\ndo \n\n```\napply le_trans _ h\n```\n\nor\n\n```\nrefine le_trans _ h\n```\n\nand this just reduces the goal to proving `x \u2264 y` immediately. \n\n", "Tip : using `le_trans`", "If $a$, $b$, $c$ are real numbers,\nthen ($a\\leq c$ and $b\\leq c$) iff $\\max(a,b)\\leq c.$\n", "end xena --hide\n", "  split,\n  { intro h,\n    cases h with hac hbc,\n    exact max_le hac hbc\n  },\n  { intro habc,\n    split,\n    { apply le_trans _ habc,\n      apply le_max_left},\n    { apply le_trans _ habc,\n      apply le_max_right\n    }\n  }\n", "Solution", "import game.max.level06 -- hide\n", "open_locale classical -- hide\n", "noncomputable theory -- hide\n", "namespace xena -- hide\n", "# Chapter ? : Max and abs\n\n## Level 7\n\n`max_lt` and `max_lt_iff` are equally useful. Let's knock them off\nusing the same techniques.\n", "If $a$, $b$, $c$ are real numbers with $a<c$ and $b<c$,\nthen $\\max(a,b)<c.$\n", "end xena --hide\n", "import game.max.level07 -- hide\n", "open_locale classical -- hide\n", "noncomputable theory -- hide\n", "namespace xena -- hide\n", "# Chapter ? : Max and abs\n\n## Level 8\n\nSee if you can do `max_lt_iff` without introducing\nany auxiliary hypotheses with `have`. Don't forget to\ncheck the list of theorems to see the interface for `\u2264`\nand `<`.\n", "If $a$, $b$, $c$ are real numbers,\nthen ($a<c$ and $b<c$) iff $\\max(a,b)<c.$\n", "end xena --hide\n", "import game.max.level08 -- hide\n", "open_locale classical -- hide\n", "noncomputable theory -- hide\n", "namespace xena -- hide\n", "# Chapter ? : Max\n\n## Level 9\n\nWe've done `max_le_iff`; here is `le_max_iff`. \n", "If $a$, $b$, $c$ are real numbers,\nthen $a\\leq\\max(b,c)$ iff ($a\\leq b$ or $a\\leq c$).\n", "end xena --hide\n", "import game.max.level09 -- hide\n", "open_locale classical -- hide\n", "noncomputable theory -- hide\n", "namespace xena -- hide\n", "# Chapter ? : Max\n\n## Level 10\n\nAnd finally `lt_max_iff`. \n", "If $a$, $b$, $c$ are real numbers,\nthen $a<\\max(b,c)$ iff ($a<b$ or $a<c$).\n", "end xena --hide\n"]]}